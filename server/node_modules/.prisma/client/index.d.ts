
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';

export import DMMF = runtime.DMMF

/**
 * Prisma Errors
 */
export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
export import PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export import sql = runtime.sqltag
export import empty = runtime.empty
export import join = runtime.join
export import raw = runtime.raw
export import Sql = runtime.Sql

/**
 * Decimal.js
 */
export import Decimal = runtime.Decimal

/**
 * Prisma Client JS version: 2.13.0
 * Query Engine version: 833ab05d2a20e822f6736a39a27de4fc8f6b3e49
 */
export type PrismaVersion = {
  client: string
}

export const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export type InputJsonObject = {[Key in string]?: JsonValue}
 
export interface InputJsonArray extends Array<JsonValue> {}
 
export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
 type SelectAndInclude = {
  select: any
  include: any
}
type HasSelect = {
  select: any
}
type HasInclude = {
  include: any
}
type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;



/**
 * Used by group by
 */
export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>

/**
 * Like `Pick`, but with an array
 */
type PickArray<T, K extends Array<keyof T>> = Pick<T, TupleToUnion<K>>





/**
 * Model Wineries
 */

export type Wineries = {
  id: number
  winery_name: string
  winery_address: string
  winery_desc: string
  coordinates: string
}

/**
 * Model WineriesImages
 */

export type WineriesImages = {
  id: number
  wineryID: number
  imageLink: string
}

/**
 * Model Vintages
 */

export type Vintages = {
  id: number
  vintage_name: string
  vintage_year: string
  assoc_winery: number
  description: string
}

/**
 * Model VintagesImages
 */

export type VintagesImages = {
  id: number
  vintagesID: number
  imageLink: string
}

/**
 * Model Reviews
 */

export type Reviews = {
  id: number
  user_id: string
  user_level: string
  user_review: string
  star_review: number
  timestamp: Date
  likes: number
  vintageID: number
}

/**
 * Model ReviewsImages
 */

export type ReviewsImages = {
  id: number
  reviewsID: number
  imageLink: string
}

/**
 * Model User_Accounts
 */

export type User_Accounts = {
  id: string
  hash: string
  email: string
  creation_Date: Date
}

/**
 * Model Users
 */

export type Users = {
  id: string
  first_name: string
  last_name: string
  new_user: boolean
  account_ID: string
  user_img: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Wineries
 * const wineries = await prisma.wineries.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Wineries
   * const wineries = await prisma.wineries.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<T>;

  /**
   * Execute queries in a transaction
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   */
  $transaction: PromiseConstructor['all']

      /**
   * `prisma.wineries`: Exposes CRUD operations for the **Wineries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wineries
    * const wineries = await prisma.wineries.findMany()
    * ```
    */
  get wineries(): Prisma.WineriesDelegate;

  /**
   * `prisma.wineriesImages`: Exposes CRUD operations for the **WineriesImages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WineriesImages
    * const wineriesImages = await prisma.wineriesImages.findMany()
    * ```
    */
  get wineriesImages(): Prisma.WineriesImagesDelegate;

  /**
   * `prisma.vintages`: Exposes CRUD operations for the **Vintages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vintages
    * const vintages = await prisma.vintages.findMany()
    * ```
    */
  get vintages(): Prisma.VintagesDelegate;

  /**
   * `prisma.vintagesImages`: Exposes CRUD operations for the **VintagesImages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VintagesImages
    * const vintagesImages = await prisma.vintagesImages.findMany()
    * ```
    */
  get vintagesImages(): Prisma.VintagesImagesDelegate;

  /**
   * `prisma.reviews`: Exposes CRUD operations for the **Reviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.reviews.findMany()
    * ```
    */
  get reviews(): Prisma.ReviewsDelegate;

  /**
   * `prisma.reviewsImages`: Exposes CRUD operations for the **ReviewsImages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewsImages
    * const reviewsImages = await prisma.reviewsImages.findMany()
    * ```
    */
  get reviewsImages(): Prisma.ReviewsImagesDelegate;

  /**
   * `prisma.user_Accounts`: Exposes CRUD operations for the **User_Accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_Accounts
    * const user_Accounts = await prisma.user_Accounts.findMany()
    * ```
    */
  get user_Accounts(): Prisma.User_AccountsDelegate;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.13.0
   * Query Engine version: 833ab05d2a20e822f6736a39a27de4fc8f6b3e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;



  /**
   * Used by group by
   */
  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Wineries: 'Wineries',
    WineriesImages: 'WineriesImages',
    Vintages: 'Vintages',
    VintagesImages: 'VintagesImages',
    Reviews: 'Reviews',
    ReviewsImages: 'ReviewsImages',
    User_Accounts: 'User_Accounts',
    Users: 'Users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model Wineries
   */


  export type AggregateWineries = {
    count: number | null
    avg: WineriesAvgAggregateOutputType | null
    sum: WineriesSumAggregateOutputType | null
    min: WineriesMinAggregateOutputType | null
    max: WineriesMaxAggregateOutputType | null
  }

  export type WineriesAvgAggregateOutputType = {
    id: number
  }

  export type WineriesSumAggregateOutputType = {
    id: number
  }

  export type WineriesMinAggregateOutputType = {
    id: number
    winery_name: string | null
    winery_address: string | null
    winery_desc: string | null
    coordinates: string | null
  }

  export type WineriesMaxAggregateOutputType = {
    id: number
    winery_name: string | null
    winery_address: string | null
    winery_desc: string | null
    coordinates: string | null
  }

  export type WineriesCountAggregateOutputType = {
    id: number
    winery_name: number | null
    winery_address: number | null
    winery_desc: number | null
    coordinates: number | null
    _all: number
  }


  export type WineriesAvgAggregateInputType = {
    id?: true
  }

  export type WineriesSumAggregateInputType = {
    id?: true
  }

  export type WineriesMinAggregateInputType = {
    id?: true
    winery_name?: true
    winery_address?: true
    winery_desc?: true
    coordinates?: true
  }

  export type WineriesMaxAggregateInputType = {
    id?: true
    winery_name?: true
    winery_address?: true
    winery_desc?: true
    coordinates?: true
  }

  export type WineriesCountAggregateInputType = {
    id?: true
    winery_name?: true
    winery_address?: true
    winery_desc?: true
    coordinates?: true
    _all?: true
  }

  export type AggregateWineriesArgs = {
    where?: WineriesWhereInput
    orderBy?: Enumerable<WineriesOrderByInput>
    cursor?: WineriesWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: WineriesAvgAggregateInputType
    sum?: WineriesSumAggregateInputType
    min?: WineriesMinAggregateInputType
    max?: WineriesMaxAggregateInputType
  }

  export type GetWineriesAggregateType<T extends AggregateWineriesArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetWineriesAggregateScalarType<T[P]>
  }

  export type GetWineriesAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof WineriesAvgAggregateOutputType ? WineriesAvgAggregateOutputType[P] : never
  }

    



  export type WineriesSelect = {
    id?: boolean
    winery_name?: boolean
    winery_address?: boolean
    winery_desc?: boolean
    coordinates?: boolean
    Vintages?: boolean | FindManyVintagesArgs
    image?: boolean | FindManyWineriesImagesArgs
  }

  export type WineriesInclude = {
    Vintages?: boolean | FindManyVintagesArgs
    image?: boolean | FindManyWineriesImagesArgs
  }

  export type WineriesGetPayload<
    S extends boolean | null | undefined | WineriesArgs,
    U = keyof S
      > = S extends true
        ? Wineries
    : S extends undefined
    ? never
    : S extends WineriesArgs | FindManyWineriesArgs
    ?'include' extends U
    ? Wineries  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Vintages'
        ? Array < VintagesGetPayload<S['include'][P]>>  :
        P extends 'image'
        ? Array < WineriesImagesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Wineries ?Wineries [P]
  : 
          P extends 'Vintages'
        ? Array < VintagesGetPayload<S['select'][P]>>  :
        P extends 'image'
        ? Array < WineriesImagesGetPayload<S['select'][P]>>  : never
  } 
    : Wineries
  : Wineries


  export interface WineriesDelegate {
    /**
     * Find zero or one Wineries that matches the filter.
     * @param {FindUniqueWineriesArgs} args - Arguments to find a Wineries
     * @example
     * // Get one Wineries
     * const wineries = await prisma.wineries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueWineriesArgs>(
      args: Subset<T, FindUniqueWineriesArgs>
    ): CheckSelect<T, Prisma__WineriesClient<Wineries | null>, Prisma__WineriesClient<WineriesGetPayload<T> | null>>
    /**
     * Find the first Wineries that matches the filter.
     * @param {FindFirstWineriesArgs} args - Arguments to find a Wineries
     * @example
     * // Get one Wineries
     * const wineries = await prisma.wineries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstWineriesArgs>(
      args?: Subset<T, FindFirstWineriesArgs>
    ): CheckSelect<T, Prisma__WineriesClient<Wineries | null>, Prisma__WineriesClient<WineriesGetPayload<T> | null>>
    /**
     * Find zero or more Wineries that matches the filter.
     * @param {FindManyWineriesArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wineries
     * const wineries = await prisma.wineries.findMany()
     * 
     * // Get first 10 Wineries
     * const wineries = await prisma.wineries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wineriesWithIdOnly = await prisma.wineries.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyWineriesArgs>(
      args?: Subset<T, FindManyWineriesArgs>
    ): CheckSelect<T, Promise<Array<Wineries>>, Promise<Array<WineriesGetPayload<T>>>>
    /**
     * Create a Wineries.
     * @param {WineriesCreateArgs} args - Arguments to create a Wineries.
     * @example
     * // Create one Wineries
     * const Wineries = await prisma.wineries.create({
     *   data: {
     *     // ... data to create a Wineries
     *   }
     * })
     * 
    **/
    create<T extends WineriesCreateArgs>(
      args: Subset<T, WineriesCreateArgs>
    ): CheckSelect<T, Prisma__WineriesClient<Wineries>, Prisma__WineriesClient<WineriesGetPayload<T>>>
    /**
     * Delete a Wineries.
     * @param {WineriesDeleteArgs} args - Arguments to delete one Wineries.
     * @example
     * // Delete one Wineries
     * const Wineries = await prisma.wineries.delete({
     *   where: {
     *     // ... filter to delete one Wineries
     *   }
     * })
     * 
    **/
    delete<T extends WineriesDeleteArgs>(
      args: Subset<T, WineriesDeleteArgs>
    ): CheckSelect<T, Prisma__WineriesClient<Wineries>, Prisma__WineriesClient<WineriesGetPayload<T>>>
    /**
     * Update one Wineries.
     * @param {WineriesUpdateArgs} args - Arguments to update one Wineries.
     * @example
     * // Update one Wineries
     * const wineries = await prisma.wineries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WineriesUpdateArgs>(
      args: Subset<T, WineriesUpdateArgs>
    ): CheckSelect<T, Prisma__WineriesClient<Wineries>, Prisma__WineriesClient<WineriesGetPayload<T>>>
    /**
     * Delete zero or more Wineries.
     * @param {WineriesDeleteManyArgs} args - Arguments to filter Wineries to delete.
     * @example
     * // Delete a few Wineries
     * const { count } = await prisma.wineries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WineriesDeleteManyArgs>(
      args?: Subset<T, WineriesDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Wineries.
     * @param {WineriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wineries
     * const wineries = await prisma.wineries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WineriesUpdateManyArgs>(
      args: Subset<T, WineriesUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Wineries.
     * @param {WineriesUpsertArgs} args - Arguments to update or create a Wineries.
     * @example
     * // Update or create a Wineries
     * const wineries = await prisma.wineries.upsert({
     *   create: {
     *     // ... data to create a Wineries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wineries we want to update
     *   }
     * })
    **/
    upsert<T extends WineriesUpsertArgs>(
      args: Subset<T, WineriesUpsertArgs>
    ): CheckSelect<T, Prisma__WineriesClient<Wineries>, Prisma__WineriesClient<WineriesGetPayload<T>>>
    /**
     * Find zero or one Wineries that matches the filter.
     * @param {FindUniqueWineriesArgs} args - Arguments to find a Wineries
     * @deprecated This will be deprecated please use prisma.wineries.findUnique
     * @example
     * // Get one Wineries
     * const wineries = await prisma.wineries.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueWineriesArgs>(
      args: Subset<T, FindUniqueWineriesArgs>
    ): CheckSelect<T, Prisma__WineriesClient<Wineries | null>, Prisma__WineriesClient<WineriesGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyWineriesArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateWineriesArgs>(args: Subset<T, AggregateWineriesArgs>): Promise<GetWineriesAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wineries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WineriesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Vintages<T extends FindManyVintagesArgs = {}>(args?: Subset<T, FindManyVintagesArgs>): CheckSelect<T, Promise<Array<Vintages>>, Promise<Array<VintagesGetPayload<T>>>>;

    image<T extends FindManyWineriesImagesArgs = {}>(args?: Subset<T, FindManyWineriesImagesArgs>): CheckSelect<T, Promise<Array<WineriesImages>>, Promise<Array<WineriesImagesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Wineries findUnique
   */
  export type FindUniqueWineriesArgs = {
    /**
     * Select specific fields to fetch from the Wineries
    **/
    select?: WineriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesInclude | null
    /**
     * Filter, which Wineries to fetch.
    **/
    where: WineriesWhereUniqueInput
  }


  /**
   * Wineries findFirst
   */
  export type FindFirstWineriesArgs = {
    /**
     * Select specific fields to fetch from the Wineries
    **/
    select?: WineriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesInclude | null
    /**
     * Filter, which Wineries to fetch.
    **/
    where?: WineriesWhereInput
    orderBy?: Enumerable<WineriesOrderByInput>
    cursor?: WineriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WineriesScalarFieldEnum>
  }


  /**
   * Wineries findMany
   */
  export type FindManyWineriesArgs = {
    /**
     * Select specific fields to fetch from the Wineries
    **/
    select?: WineriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesInclude | null
    /**
     * Filter, which Wineries to fetch.
    **/
    where?: WineriesWhereInput
    /**
     * Determine the order of the Wineries to fetch.
    **/
    orderBy?: Enumerable<WineriesOrderByInput>
    /**
     * Sets the position for listing Wineries.
    **/
    cursor?: WineriesWhereUniqueInput
    /**
     * The number of Wineries to fetch. If negative number, it will take Wineries before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` Wineries.
    **/
    skip?: number
    distinct?: Enumerable<WineriesScalarFieldEnum>
  }


  /**
   * Wineries create
   */
  export type WineriesCreateArgs = {
    /**
     * Select specific fields to fetch from the Wineries
    **/
    select?: WineriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesInclude | null
    /**
     * The data needed to create a Wineries.
    **/
    data: WineriesCreateInput
  }


  /**
   * Wineries update
   */
  export type WineriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Wineries
    **/
    select?: WineriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesInclude | null
    /**
     * The data needed to update a Wineries.
    **/
    data: WineriesUpdateInput
    /**
     * Choose, which Wineries to update.
    **/
    where: WineriesWhereUniqueInput
  }


  /**
   * Wineries updateMany
   */
  export type WineriesUpdateManyArgs = {
    data: WineriesUpdateManyMutationInput
    where?: WineriesWhereInput
  }


  /**
   * Wineries upsert
   */
  export type WineriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Wineries
    **/
    select?: WineriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesInclude | null
    /**
     * The filter to search for the Wineries to update in case it exists.
    **/
    where: WineriesWhereUniqueInput
    /**
     * In case the Wineries found by the `where` argument doesn't exist, create a new Wineries with this data.
    **/
    create: WineriesCreateInput
    /**
     * In case the Wineries was found with the provided `where` argument, update it with this data.
    **/
    update: WineriesUpdateInput
  }


  /**
   * Wineries delete
   */
  export type WineriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Wineries
    **/
    select?: WineriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesInclude | null
    /**
     * Filter which Wineries to delete.
    **/
    where: WineriesWhereUniqueInput
  }


  /**
   * Wineries deleteMany
   */
  export type WineriesDeleteManyArgs = {
    where?: WineriesWhereInput
  }


  /**
   * Wineries without action
   */
  export type WineriesArgs = {
    /**
     * Select specific fields to fetch from the Wineries
    **/
    select?: WineriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesInclude | null
  }



  /**
   * Model WineriesImages
   */


  export type AggregateWineriesImages = {
    count: number | null
    avg: WineriesImagesAvgAggregateOutputType | null
    sum: WineriesImagesSumAggregateOutputType | null
    min: WineriesImagesMinAggregateOutputType | null
    max: WineriesImagesMaxAggregateOutputType | null
  }

  export type WineriesImagesAvgAggregateOutputType = {
    id: number
    wineryID: number
  }

  export type WineriesImagesSumAggregateOutputType = {
    id: number
    wineryID: number
  }

  export type WineriesImagesMinAggregateOutputType = {
    id: number
    wineryID: number
    imageLink: string | null
  }

  export type WineriesImagesMaxAggregateOutputType = {
    id: number
    wineryID: number
    imageLink: string | null
  }

  export type WineriesImagesCountAggregateOutputType = {
    id: number
    wineryID: number
    imageLink: number | null
    _all: number
  }


  export type WineriesImagesAvgAggregateInputType = {
    id?: true
    wineryID?: true
  }

  export type WineriesImagesSumAggregateInputType = {
    id?: true
    wineryID?: true
  }

  export type WineriesImagesMinAggregateInputType = {
    id?: true
    wineryID?: true
    imageLink?: true
  }

  export type WineriesImagesMaxAggregateInputType = {
    id?: true
    wineryID?: true
    imageLink?: true
  }

  export type WineriesImagesCountAggregateInputType = {
    id?: true
    wineryID?: true
    imageLink?: true
    _all?: true
  }

  export type AggregateWineriesImagesArgs = {
    where?: WineriesImagesWhereInput
    orderBy?: Enumerable<WineriesImagesOrderByInput>
    cursor?: WineriesImagesWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: WineriesImagesAvgAggregateInputType
    sum?: WineriesImagesSumAggregateInputType
    min?: WineriesImagesMinAggregateInputType
    max?: WineriesImagesMaxAggregateInputType
  }

  export type GetWineriesImagesAggregateType<T extends AggregateWineriesImagesArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetWineriesImagesAggregateScalarType<T[P]>
  }

  export type GetWineriesImagesAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof WineriesImagesAvgAggregateOutputType ? WineriesImagesAvgAggregateOutputType[P] : never
  }

    



  export type WineriesImagesSelect = {
    id?: boolean
    wineryID?: boolean
    imageLink?: boolean
    Wineries?: boolean | WineriesArgs
  }

  export type WineriesImagesInclude = {
    Wineries?: boolean | WineriesArgs
  }

  export type WineriesImagesGetPayload<
    S extends boolean | null | undefined | WineriesImagesArgs,
    U = keyof S
      > = S extends true
        ? WineriesImages
    : S extends undefined
    ? never
    : S extends WineriesImagesArgs | FindManyWineriesImagesArgs
    ?'include' extends U
    ? WineriesImages  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Wineries'
        ? WineriesGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WineriesImages ?WineriesImages [P]
  : 
          P extends 'Wineries'
        ? WineriesGetPayload<S['select'][P]> : never
  } 
    : WineriesImages
  : WineriesImages


  export interface WineriesImagesDelegate {
    /**
     * Find zero or one WineriesImages that matches the filter.
     * @param {FindUniqueWineriesImagesArgs} args - Arguments to find a WineriesImages
     * @example
     * // Get one WineriesImages
     * const wineriesImages = await prisma.wineriesImages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueWineriesImagesArgs>(
      args: Subset<T, FindUniqueWineriesImagesArgs>
    ): CheckSelect<T, Prisma__WineriesImagesClient<WineriesImages | null>, Prisma__WineriesImagesClient<WineriesImagesGetPayload<T> | null>>
    /**
     * Find the first WineriesImages that matches the filter.
     * @param {FindFirstWineriesImagesArgs} args - Arguments to find a WineriesImages
     * @example
     * // Get one WineriesImages
     * const wineriesImages = await prisma.wineriesImages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstWineriesImagesArgs>(
      args?: Subset<T, FindFirstWineriesImagesArgs>
    ): CheckSelect<T, Prisma__WineriesImagesClient<WineriesImages | null>, Prisma__WineriesImagesClient<WineriesImagesGetPayload<T> | null>>
    /**
     * Find zero or more WineriesImages that matches the filter.
     * @param {FindManyWineriesImagesArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WineriesImages
     * const wineriesImages = await prisma.wineriesImages.findMany()
     * 
     * // Get first 10 WineriesImages
     * const wineriesImages = await prisma.wineriesImages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wineriesImagesWithIdOnly = await prisma.wineriesImages.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyWineriesImagesArgs>(
      args?: Subset<T, FindManyWineriesImagesArgs>
    ): CheckSelect<T, Promise<Array<WineriesImages>>, Promise<Array<WineriesImagesGetPayload<T>>>>
    /**
     * Create a WineriesImages.
     * @param {WineriesImagesCreateArgs} args - Arguments to create a WineriesImages.
     * @example
     * // Create one WineriesImages
     * const WineriesImages = await prisma.wineriesImages.create({
     *   data: {
     *     // ... data to create a WineriesImages
     *   }
     * })
     * 
    **/
    create<T extends WineriesImagesCreateArgs>(
      args: Subset<T, WineriesImagesCreateArgs>
    ): CheckSelect<T, Prisma__WineriesImagesClient<WineriesImages>, Prisma__WineriesImagesClient<WineriesImagesGetPayload<T>>>
    /**
     * Delete a WineriesImages.
     * @param {WineriesImagesDeleteArgs} args - Arguments to delete one WineriesImages.
     * @example
     * // Delete one WineriesImages
     * const WineriesImages = await prisma.wineriesImages.delete({
     *   where: {
     *     // ... filter to delete one WineriesImages
     *   }
     * })
     * 
    **/
    delete<T extends WineriesImagesDeleteArgs>(
      args: Subset<T, WineriesImagesDeleteArgs>
    ): CheckSelect<T, Prisma__WineriesImagesClient<WineriesImages>, Prisma__WineriesImagesClient<WineriesImagesGetPayload<T>>>
    /**
     * Update one WineriesImages.
     * @param {WineriesImagesUpdateArgs} args - Arguments to update one WineriesImages.
     * @example
     * // Update one WineriesImages
     * const wineriesImages = await prisma.wineriesImages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WineriesImagesUpdateArgs>(
      args: Subset<T, WineriesImagesUpdateArgs>
    ): CheckSelect<T, Prisma__WineriesImagesClient<WineriesImages>, Prisma__WineriesImagesClient<WineriesImagesGetPayload<T>>>
    /**
     * Delete zero or more WineriesImages.
     * @param {WineriesImagesDeleteManyArgs} args - Arguments to filter WineriesImages to delete.
     * @example
     * // Delete a few WineriesImages
     * const { count } = await prisma.wineriesImages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WineriesImagesDeleteManyArgs>(
      args?: Subset<T, WineriesImagesDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more WineriesImages.
     * @param {WineriesImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WineriesImages
     * const wineriesImages = await prisma.wineriesImages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WineriesImagesUpdateManyArgs>(
      args: Subset<T, WineriesImagesUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one WineriesImages.
     * @param {WineriesImagesUpsertArgs} args - Arguments to update or create a WineriesImages.
     * @example
     * // Update or create a WineriesImages
     * const wineriesImages = await prisma.wineriesImages.upsert({
     *   create: {
     *     // ... data to create a WineriesImages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WineriesImages we want to update
     *   }
     * })
    **/
    upsert<T extends WineriesImagesUpsertArgs>(
      args: Subset<T, WineriesImagesUpsertArgs>
    ): CheckSelect<T, Prisma__WineriesImagesClient<WineriesImages>, Prisma__WineriesImagesClient<WineriesImagesGetPayload<T>>>
    /**
     * Find zero or one WineriesImages that matches the filter.
     * @param {FindUniqueWineriesImagesArgs} args - Arguments to find a WineriesImages
     * @deprecated This will be deprecated please use prisma.wineriesImages.findUnique
     * @example
     * // Get one WineriesImages
     * const wineriesImages = await prisma.wineriesImages.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueWineriesImagesArgs>(
      args: Subset<T, FindUniqueWineriesImagesArgs>
    ): CheckSelect<T, Prisma__WineriesImagesClient<WineriesImages | null>, Prisma__WineriesImagesClient<WineriesImagesGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyWineriesImagesArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateWineriesImagesArgs>(args: Subset<T, AggregateWineriesImagesArgs>): Promise<GetWineriesImagesAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for WineriesImages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WineriesImagesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Wineries<T extends WineriesArgs = {}>(args?: Subset<T, WineriesArgs>): CheckSelect<T, Prisma__WineriesClient<Wineries | null>, Prisma__WineriesClient<WineriesGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * WineriesImages findUnique
   */
  export type FindUniqueWineriesImagesArgs = {
    /**
     * Select specific fields to fetch from the WineriesImages
    **/
    select?: WineriesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesImagesInclude | null
    /**
     * Filter, which WineriesImages to fetch.
    **/
    where: WineriesImagesWhereUniqueInput
  }


  /**
   * WineriesImages findFirst
   */
  export type FindFirstWineriesImagesArgs = {
    /**
     * Select specific fields to fetch from the WineriesImages
    **/
    select?: WineriesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesImagesInclude | null
    /**
     * Filter, which WineriesImages to fetch.
    **/
    where?: WineriesImagesWhereInput
    orderBy?: Enumerable<WineriesImagesOrderByInput>
    cursor?: WineriesImagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WineriesImagesScalarFieldEnum>
  }


  /**
   * WineriesImages findMany
   */
  export type FindManyWineriesImagesArgs = {
    /**
     * Select specific fields to fetch from the WineriesImages
    **/
    select?: WineriesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesImagesInclude | null
    /**
     * Filter, which WineriesImages to fetch.
    **/
    where?: WineriesImagesWhereInput
    /**
     * Determine the order of the WineriesImages to fetch.
    **/
    orderBy?: Enumerable<WineriesImagesOrderByInput>
    /**
     * Sets the position for listing WineriesImages.
    **/
    cursor?: WineriesImagesWhereUniqueInput
    /**
     * The number of WineriesImages to fetch. If negative number, it will take WineriesImages before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` WineriesImages.
    **/
    skip?: number
    distinct?: Enumerable<WineriesImagesScalarFieldEnum>
  }


  /**
   * WineriesImages create
   */
  export type WineriesImagesCreateArgs = {
    /**
     * Select specific fields to fetch from the WineriesImages
    **/
    select?: WineriesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesImagesInclude | null
    /**
     * The data needed to create a WineriesImages.
    **/
    data: WineriesImagesCreateInput
  }


  /**
   * WineriesImages update
   */
  export type WineriesImagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the WineriesImages
    **/
    select?: WineriesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesImagesInclude | null
    /**
     * The data needed to update a WineriesImages.
    **/
    data: WineriesImagesUpdateInput
    /**
     * Choose, which WineriesImages to update.
    **/
    where: WineriesImagesWhereUniqueInput
  }


  /**
   * WineriesImages updateMany
   */
  export type WineriesImagesUpdateManyArgs = {
    data: WineriesImagesUpdateManyMutationInput
    where?: WineriesImagesWhereInput
  }


  /**
   * WineriesImages upsert
   */
  export type WineriesImagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the WineriesImages
    **/
    select?: WineriesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesImagesInclude | null
    /**
     * The filter to search for the WineriesImages to update in case it exists.
    **/
    where: WineriesImagesWhereUniqueInput
    /**
     * In case the WineriesImages found by the `where` argument doesn't exist, create a new WineriesImages with this data.
    **/
    create: WineriesImagesCreateInput
    /**
     * In case the WineriesImages was found with the provided `where` argument, update it with this data.
    **/
    update: WineriesImagesUpdateInput
  }


  /**
   * WineriesImages delete
   */
  export type WineriesImagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the WineriesImages
    **/
    select?: WineriesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesImagesInclude | null
    /**
     * Filter which WineriesImages to delete.
    **/
    where: WineriesImagesWhereUniqueInput
  }


  /**
   * WineriesImages deleteMany
   */
  export type WineriesImagesDeleteManyArgs = {
    where?: WineriesImagesWhereInput
  }


  /**
   * WineriesImages without action
   */
  export type WineriesImagesArgs = {
    /**
     * Select specific fields to fetch from the WineriesImages
    **/
    select?: WineriesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WineriesImagesInclude | null
  }



  /**
   * Model Vintages
   */


  export type AggregateVintages = {
    count: number | null
    avg: VintagesAvgAggregateOutputType | null
    sum: VintagesSumAggregateOutputType | null
    min: VintagesMinAggregateOutputType | null
    max: VintagesMaxAggregateOutputType | null
  }

  export type VintagesAvgAggregateOutputType = {
    id: number
    assoc_winery: number
  }

  export type VintagesSumAggregateOutputType = {
    id: number
    assoc_winery: number
  }

  export type VintagesMinAggregateOutputType = {
    id: number
    vintage_name: string | null
    vintage_year: string | null
    assoc_winery: number
    description: string | null
  }

  export type VintagesMaxAggregateOutputType = {
    id: number
    vintage_name: string | null
    vintage_year: string | null
    assoc_winery: number
    description: string | null
  }

  export type VintagesCountAggregateOutputType = {
    id: number
    vintage_name: number | null
    vintage_year: number | null
    assoc_winery: number
    description: number | null
    _all: number
  }


  export type VintagesAvgAggregateInputType = {
    id?: true
    assoc_winery?: true
  }

  export type VintagesSumAggregateInputType = {
    id?: true
    assoc_winery?: true
  }

  export type VintagesMinAggregateInputType = {
    id?: true
    vintage_name?: true
    vintage_year?: true
    assoc_winery?: true
    description?: true
  }

  export type VintagesMaxAggregateInputType = {
    id?: true
    vintage_name?: true
    vintage_year?: true
    assoc_winery?: true
    description?: true
  }

  export type VintagesCountAggregateInputType = {
    id?: true
    vintage_name?: true
    vintage_year?: true
    assoc_winery?: true
    description?: true
    _all?: true
  }

  export type AggregateVintagesArgs = {
    where?: VintagesWhereInput
    orderBy?: Enumerable<VintagesOrderByInput>
    cursor?: VintagesWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: VintagesAvgAggregateInputType
    sum?: VintagesSumAggregateInputType
    min?: VintagesMinAggregateInputType
    max?: VintagesMaxAggregateInputType
  }

  export type GetVintagesAggregateType<T extends AggregateVintagesArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetVintagesAggregateScalarType<T[P]>
  }

  export type GetVintagesAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof VintagesAvgAggregateOutputType ? VintagesAvgAggregateOutputType[P] : never
  }

    



  export type VintagesSelect = {
    id?: boolean
    vintage_name?: boolean
    vintage_year?: boolean
    assoc_winery?: boolean
    description?: boolean
    Wineries?: boolean | WineriesArgs
    Reviews?: boolean | FindManyReviewsArgs
    images?: boolean | FindManyVintagesImagesArgs
  }

  export type VintagesInclude = {
    Wineries?: boolean | WineriesArgs
    Reviews?: boolean | FindManyReviewsArgs
    images?: boolean | FindManyVintagesImagesArgs
  }

  export type VintagesGetPayload<
    S extends boolean | null | undefined | VintagesArgs,
    U = keyof S
      > = S extends true
        ? Vintages
    : S extends undefined
    ? never
    : S extends VintagesArgs | FindManyVintagesArgs
    ?'include' extends U
    ? Vintages  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Wineries'
        ? WineriesGetPayload<S['include'][P]> :
        P extends 'Reviews'
        ? Array < ReviewsGetPayload<S['include'][P]>>  :
        P extends 'images'
        ? Array < VintagesImagesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Vintages ?Vintages [P]
  : 
          P extends 'Wineries'
        ? WineriesGetPayload<S['select'][P]> :
        P extends 'Reviews'
        ? Array < ReviewsGetPayload<S['select'][P]>>  :
        P extends 'images'
        ? Array < VintagesImagesGetPayload<S['select'][P]>>  : never
  } 
    : Vintages
  : Vintages


  export interface VintagesDelegate {
    /**
     * Find zero or one Vintages that matches the filter.
     * @param {FindUniqueVintagesArgs} args - Arguments to find a Vintages
     * @example
     * // Get one Vintages
     * const vintages = await prisma.vintages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueVintagesArgs>(
      args: Subset<T, FindUniqueVintagesArgs>
    ): CheckSelect<T, Prisma__VintagesClient<Vintages | null>, Prisma__VintagesClient<VintagesGetPayload<T> | null>>
    /**
     * Find the first Vintages that matches the filter.
     * @param {FindFirstVintagesArgs} args - Arguments to find a Vintages
     * @example
     * // Get one Vintages
     * const vintages = await prisma.vintages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstVintagesArgs>(
      args?: Subset<T, FindFirstVintagesArgs>
    ): CheckSelect<T, Prisma__VintagesClient<Vintages | null>, Prisma__VintagesClient<VintagesGetPayload<T> | null>>
    /**
     * Find zero or more Vintages that matches the filter.
     * @param {FindManyVintagesArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vintages
     * const vintages = await prisma.vintages.findMany()
     * 
     * // Get first 10 Vintages
     * const vintages = await prisma.vintages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vintagesWithIdOnly = await prisma.vintages.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyVintagesArgs>(
      args?: Subset<T, FindManyVintagesArgs>
    ): CheckSelect<T, Promise<Array<Vintages>>, Promise<Array<VintagesGetPayload<T>>>>
    /**
     * Create a Vintages.
     * @param {VintagesCreateArgs} args - Arguments to create a Vintages.
     * @example
     * // Create one Vintages
     * const Vintages = await prisma.vintages.create({
     *   data: {
     *     // ... data to create a Vintages
     *   }
     * })
     * 
    **/
    create<T extends VintagesCreateArgs>(
      args: Subset<T, VintagesCreateArgs>
    ): CheckSelect<T, Prisma__VintagesClient<Vintages>, Prisma__VintagesClient<VintagesGetPayload<T>>>
    /**
     * Delete a Vintages.
     * @param {VintagesDeleteArgs} args - Arguments to delete one Vintages.
     * @example
     * // Delete one Vintages
     * const Vintages = await prisma.vintages.delete({
     *   where: {
     *     // ... filter to delete one Vintages
     *   }
     * })
     * 
    **/
    delete<T extends VintagesDeleteArgs>(
      args: Subset<T, VintagesDeleteArgs>
    ): CheckSelect<T, Prisma__VintagesClient<Vintages>, Prisma__VintagesClient<VintagesGetPayload<T>>>
    /**
     * Update one Vintages.
     * @param {VintagesUpdateArgs} args - Arguments to update one Vintages.
     * @example
     * // Update one Vintages
     * const vintages = await prisma.vintages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VintagesUpdateArgs>(
      args: Subset<T, VintagesUpdateArgs>
    ): CheckSelect<T, Prisma__VintagesClient<Vintages>, Prisma__VintagesClient<VintagesGetPayload<T>>>
    /**
     * Delete zero or more Vintages.
     * @param {VintagesDeleteManyArgs} args - Arguments to filter Vintages to delete.
     * @example
     * // Delete a few Vintages
     * const { count } = await prisma.vintages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VintagesDeleteManyArgs>(
      args?: Subset<T, VintagesDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Vintages.
     * @param {VintagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vintages
     * const vintages = await prisma.vintages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VintagesUpdateManyArgs>(
      args: Subset<T, VintagesUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Vintages.
     * @param {VintagesUpsertArgs} args - Arguments to update or create a Vintages.
     * @example
     * // Update or create a Vintages
     * const vintages = await prisma.vintages.upsert({
     *   create: {
     *     // ... data to create a Vintages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vintages we want to update
     *   }
     * })
    **/
    upsert<T extends VintagesUpsertArgs>(
      args: Subset<T, VintagesUpsertArgs>
    ): CheckSelect<T, Prisma__VintagesClient<Vintages>, Prisma__VintagesClient<VintagesGetPayload<T>>>
    /**
     * Find zero or one Vintages that matches the filter.
     * @param {FindUniqueVintagesArgs} args - Arguments to find a Vintages
     * @deprecated This will be deprecated please use prisma.vintages.findUnique
     * @example
     * // Get one Vintages
     * const vintages = await prisma.vintages.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueVintagesArgs>(
      args: Subset<T, FindUniqueVintagesArgs>
    ): CheckSelect<T, Prisma__VintagesClient<Vintages | null>, Prisma__VintagesClient<VintagesGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyVintagesArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateVintagesArgs>(args: Subset<T, AggregateVintagesArgs>): Promise<GetVintagesAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vintages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VintagesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Wineries<T extends WineriesArgs = {}>(args?: Subset<T, WineriesArgs>): CheckSelect<T, Prisma__WineriesClient<Wineries | null>, Prisma__WineriesClient<WineriesGetPayload<T> | null>>;

    Reviews<T extends FindManyReviewsArgs = {}>(args?: Subset<T, FindManyReviewsArgs>): CheckSelect<T, Promise<Array<Reviews>>, Promise<Array<ReviewsGetPayload<T>>>>;

    images<T extends FindManyVintagesImagesArgs = {}>(args?: Subset<T, FindManyVintagesImagesArgs>): CheckSelect<T, Promise<Array<VintagesImages>>, Promise<Array<VintagesImagesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Vintages findUnique
   */
  export type FindUniqueVintagesArgs = {
    /**
     * Select specific fields to fetch from the Vintages
    **/
    select?: VintagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesInclude | null
    /**
     * Filter, which Vintages to fetch.
    **/
    where: VintagesWhereUniqueInput
  }


  /**
   * Vintages findFirst
   */
  export type FindFirstVintagesArgs = {
    /**
     * Select specific fields to fetch from the Vintages
    **/
    select?: VintagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesInclude | null
    /**
     * Filter, which Vintages to fetch.
    **/
    where?: VintagesWhereInput
    orderBy?: Enumerable<VintagesOrderByInput>
    cursor?: VintagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VintagesScalarFieldEnum>
  }


  /**
   * Vintages findMany
   */
  export type FindManyVintagesArgs = {
    /**
     * Select specific fields to fetch from the Vintages
    **/
    select?: VintagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesInclude | null
    /**
     * Filter, which Vintages to fetch.
    **/
    where?: VintagesWhereInput
    /**
     * Determine the order of the Vintages to fetch.
    **/
    orderBy?: Enumerable<VintagesOrderByInput>
    /**
     * Sets the position for listing Vintages.
    **/
    cursor?: VintagesWhereUniqueInput
    /**
     * The number of Vintages to fetch. If negative number, it will take Vintages before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` Vintages.
    **/
    skip?: number
    distinct?: Enumerable<VintagesScalarFieldEnum>
  }


  /**
   * Vintages create
   */
  export type VintagesCreateArgs = {
    /**
     * Select specific fields to fetch from the Vintages
    **/
    select?: VintagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesInclude | null
    /**
     * The data needed to create a Vintages.
    **/
    data: VintagesCreateInput
  }


  /**
   * Vintages update
   */
  export type VintagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Vintages
    **/
    select?: VintagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesInclude | null
    /**
     * The data needed to update a Vintages.
    **/
    data: VintagesUpdateInput
    /**
     * Choose, which Vintages to update.
    **/
    where: VintagesWhereUniqueInput
  }


  /**
   * Vintages updateMany
   */
  export type VintagesUpdateManyArgs = {
    data: VintagesUpdateManyMutationInput
    where?: VintagesWhereInput
  }


  /**
   * Vintages upsert
   */
  export type VintagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Vintages
    **/
    select?: VintagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesInclude | null
    /**
     * The filter to search for the Vintages to update in case it exists.
    **/
    where: VintagesWhereUniqueInput
    /**
     * In case the Vintages found by the `where` argument doesn't exist, create a new Vintages with this data.
    **/
    create: VintagesCreateInput
    /**
     * In case the Vintages was found with the provided `where` argument, update it with this data.
    **/
    update: VintagesUpdateInput
  }


  /**
   * Vintages delete
   */
  export type VintagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Vintages
    **/
    select?: VintagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesInclude | null
    /**
     * Filter which Vintages to delete.
    **/
    where: VintagesWhereUniqueInput
  }


  /**
   * Vintages deleteMany
   */
  export type VintagesDeleteManyArgs = {
    where?: VintagesWhereInput
  }


  /**
   * Vintages without action
   */
  export type VintagesArgs = {
    /**
     * Select specific fields to fetch from the Vintages
    **/
    select?: VintagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesInclude | null
  }



  /**
   * Model VintagesImages
   */


  export type AggregateVintagesImages = {
    count: number | null
    avg: VintagesImagesAvgAggregateOutputType | null
    sum: VintagesImagesSumAggregateOutputType | null
    min: VintagesImagesMinAggregateOutputType | null
    max: VintagesImagesMaxAggregateOutputType | null
  }

  export type VintagesImagesAvgAggregateOutputType = {
    id: number
    vintagesID: number
  }

  export type VintagesImagesSumAggregateOutputType = {
    id: number
    vintagesID: number
  }

  export type VintagesImagesMinAggregateOutputType = {
    id: number
    vintagesID: number
    imageLink: string | null
  }

  export type VintagesImagesMaxAggregateOutputType = {
    id: number
    vintagesID: number
    imageLink: string | null
  }

  export type VintagesImagesCountAggregateOutputType = {
    id: number
    vintagesID: number
    imageLink: number | null
    _all: number
  }


  export type VintagesImagesAvgAggregateInputType = {
    id?: true
    vintagesID?: true
  }

  export type VintagesImagesSumAggregateInputType = {
    id?: true
    vintagesID?: true
  }

  export type VintagesImagesMinAggregateInputType = {
    id?: true
    vintagesID?: true
    imageLink?: true
  }

  export type VintagesImagesMaxAggregateInputType = {
    id?: true
    vintagesID?: true
    imageLink?: true
  }

  export type VintagesImagesCountAggregateInputType = {
    id?: true
    vintagesID?: true
    imageLink?: true
    _all?: true
  }

  export type AggregateVintagesImagesArgs = {
    where?: VintagesImagesWhereInput
    orderBy?: Enumerable<VintagesImagesOrderByInput>
    cursor?: VintagesImagesWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: VintagesImagesAvgAggregateInputType
    sum?: VintagesImagesSumAggregateInputType
    min?: VintagesImagesMinAggregateInputType
    max?: VintagesImagesMaxAggregateInputType
  }

  export type GetVintagesImagesAggregateType<T extends AggregateVintagesImagesArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetVintagesImagesAggregateScalarType<T[P]>
  }

  export type GetVintagesImagesAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof VintagesImagesAvgAggregateOutputType ? VintagesImagesAvgAggregateOutputType[P] : never
  }

    



  export type VintagesImagesSelect = {
    id?: boolean
    vintagesID?: boolean
    imageLink?: boolean
    Vintages?: boolean | VintagesArgs
  }

  export type VintagesImagesInclude = {
    Vintages?: boolean | VintagesArgs
  }

  export type VintagesImagesGetPayload<
    S extends boolean | null | undefined | VintagesImagesArgs,
    U = keyof S
      > = S extends true
        ? VintagesImages
    : S extends undefined
    ? never
    : S extends VintagesImagesArgs | FindManyVintagesImagesArgs
    ?'include' extends U
    ? VintagesImages  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Vintages'
        ? VintagesGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof VintagesImages ?VintagesImages [P]
  : 
          P extends 'Vintages'
        ? VintagesGetPayload<S['select'][P]> : never
  } 
    : VintagesImages
  : VintagesImages


  export interface VintagesImagesDelegate {
    /**
     * Find zero or one VintagesImages that matches the filter.
     * @param {FindUniqueVintagesImagesArgs} args - Arguments to find a VintagesImages
     * @example
     * // Get one VintagesImages
     * const vintagesImages = await prisma.vintagesImages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueVintagesImagesArgs>(
      args: Subset<T, FindUniqueVintagesImagesArgs>
    ): CheckSelect<T, Prisma__VintagesImagesClient<VintagesImages | null>, Prisma__VintagesImagesClient<VintagesImagesGetPayload<T> | null>>
    /**
     * Find the first VintagesImages that matches the filter.
     * @param {FindFirstVintagesImagesArgs} args - Arguments to find a VintagesImages
     * @example
     * // Get one VintagesImages
     * const vintagesImages = await prisma.vintagesImages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstVintagesImagesArgs>(
      args?: Subset<T, FindFirstVintagesImagesArgs>
    ): CheckSelect<T, Prisma__VintagesImagesClient<VintagesImages | null>, Prisma__VintagesImagesClient<VintagesImagesGetPayload<T> | null>>
    /**
     * Find zero or more VintagesImages that matches the filter.
     * @param {FindManyVintagesImagesArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VintagesImages
     * const vintagesImages = await prisma.vintagesImages.findMany()
     * 
     * // Get first 10 VintagesImages
     * const vintagesImages = await prisma.vintagesImages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vintagesImagesWithIdOnly = await prisma.vintagesImages.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyVintagesImagesArgs>(
      args?: Subset<T, FindManyVintagesImagesArgs>
    ): CheckSelect<T, Promise<Array<VintagesImages>>, Promise<Array<VintagesImagesGetPayload<T>>>>
    /**
     * Create a VintagesImages.
     * @param {VintagesImagesCreateArgs} args - Arguments to create a VintagesImages.
     * @example
     * // Create one VintagesImages
     * const VintagesImages = await prisma.vintagesImages.create({
     *   data: {
     *     // ... data to create a VintagesImages
     *   }
     * })
     * 
    **/
    create<T extends VintagesImagesCreateArgs>(
      args: Subset<T, VintagesImagesCreateArgs>
    ): CheckSelect<T, Prisma__VintagesImagesClient<VintagesImages>, Prisma__VintagesImagesClient<VintagesImagesGetPayload<T>>>
    /**
     * Delete a VintagesImages.
     * @param {VintagesImagesDeleteArgs} args - Arguments to delete one VintagesImages.
     * @example
     * // Delete one VintagesImages
     * const VintagesImages = await prisma.vintagesImages.delete({
     *   where: {
     *     // ... filter to delete one VintagesImages
     *   }
     * })
     * 
    **/
    delete<T extends VintagesImagesDeleteArgs>(
      args: Subset<T, VintagesImagesDeleteArgs>
    ): CheckSelect<T, Prisma__VintagesImagesClient<VintagesImages>, Prisma__VintagesImagesClient<VintagesImagesGetPayload<T>>>
    /**
     * Update one VintagesImages.
     * @param {VintagesImagesUpdateArgs} args - Arguments to update one VintagesImages.
     * @example
     * // Update one VintagesImages
     * const vintagesImages = await prisma.vintagesImages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VintagesImagesUpdateArgs>(
      args: Subset<T, VintagesImagesUpdateArgs>
    ): CheckSelect<T, Prisma__VintagesImagesClient<VintagesImages>, Prisma__VintagesImagesClient<VintagesImagesGetPayload<T>>>
    /**
     * Delete zero or more VintagesImages.
     * @param {VintagesImagesDeleteManyArgs} args - Arguments to filter VintagesImages to delete.
     * @example
     * // Delete a few VintagesImages
     * const { count } = await prisma.vintagesImages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VintagesImagesDeleteManyArgs>(
      args?: Subset<T, VintagesImagesDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more VintagesImages.
     * @param {VintagesImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VintagesImages
     * const vintagesImages = await prisma.vintagesImages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VintagesImagesUpdateManyArgs>(
      args: Subset<T, VintagesImagesUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one VintagesImages.
     * @param {VintagesImagesUpsertArgs} args - Arguments to update or create a VintagesImages.
     * @example
     * // Update or create a VintagesImages
     * const vintagesImages = await prisma.vintagesImages.upsert({
     *   create: {
     *     // ... data to create a VintagesImages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VintagesImages we want to update
     *   }
     * })
    **/
    upsert<T extends VintagesImagesUpsertArgs>(
      args: Subset<T, VintagesImagesUpsertArgs>
    ): CheckSelect<T, Prisma__VintagesImagesClient<VintagesImages>, Prisma__VintagesImagesClient<VintagesImagesGetPayload<T>>>
    /**
     * Find zero or one VintagesImages that matches the filter.
     * @param {FindUniqueVintagesImagesArgs} args - Arguments to find a VintagesImages
     * @deprecated This will be deprecated please use prisma.vintagesImages.findUnique
     * @example
     * // Get one VintagesImages
     * const vintagesImages = await prisma.vintagesImages.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueVintagesImagesArgs>(
      args: Subset<T, FindUniqueVintagesImagesArgs>
    ): CheckSelect<T, Prisma__VintagesImagesClient<VintagesImages | null>, Prisma__VintagesImagesClient<VintagesImagesGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyVintagesImagesArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateVintagesImagesArgs>(args: Subset<T, AggregateVintagesImagesArgs>): Promise<GetVintagesImagesAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VintagesImages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VintagesImagesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Vintages<T extends VintagesArgs = {}>(args?: Subset<T, VintagesArgs>): CheckSelect<T, Prisma__VintagesClient<Vintages | null>, Prisma__VintagesClient<VintagesGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VintagesImages findUnique
   */
  export type FindUniqueVintagesImagesArgs = {
    /**
     * Select specific fields to fetch from the VintagesImages
    **/
    select?: VintagesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesImagesInclude | null
    /**
     * Filter, which VintagesImages to fetch.
    **/
    where: VintagesImagesWhereUniqueInput
  }


  /**
   * VintagesImages findFirst
   */
  export type FindFirstVintagesImagesArgs = {
    /**
     * Select specific fields to fetch from the VintagesImages
    **/
    select?: VintagesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesImagesInclude | null
    /**
     * Filter, which VintagesImages to fetch.
    **/
    where?: VintagesImagesWhereInput
    orderBy?: Enumerable<VintagesImagesOrderByInput>
    cursor?: VintagesImagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VintagesImagesScalarFieldEnum>
  }


  /**
   * VintagesImages findMany
   */
  export type FindManyVintagesImagesArgs = {
    /**
     * Select specific fields to fetch from the VintagesImages
    **/
    select?: VintagesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesImagesInclude | null
    /**
     * Filter, which VintagesImages to fetch.
    **/
    where?: VintagesImagesWhereInput
    /**
     * Determine the order of the VintagesImages to fetch.
    **/
    orderBy?: Enumerable<VintagesImagesOrderByInput>
    /**
     * Sets the position for listing VintagesImages.
    **/
    cursor?: VintagesImagesWhereUniqueInput
    /**
     * The number of VintagesImages to fetch. If negative number, it will take VintagesImages before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` VintagesImages.
    **/
    skip?: number
    distinct?: Enumerable<VintagesImagesScalarFieldEnum>
  }


  /**
   * VintagesImages create
   */
  export type VintagesImagesCreateArgs = {
    /**
     * Select specific fields to fetch from the VintagesImages
    **/
    select?: VintagesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesImagesInclude | null
    /**
     * The data needed to create a VintagesImages.
    **/
    data: VintagesImagesCreateInput
  }


  /**
   * VintagesImages update
   */
  export type VintagesImagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the VintagesImages
    **/
    select?: VintagesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesImagesInclude | null
    /**
     * The data needed to update a VintagesImages.
    **/
    data: VintagesImagesUpdateInput
    /**
     * Choose, which VintagesImages to update.
    **/
    where: VintagesImagesWhereUniqueInput
  }


  /**
   * VintagesImages updateMany
   */
  export type VintagesImagesUpdateManyArgs = {
    data: VintagesImagesUpdateManyMutationInput
    where?: VintagesImagesWhereInput
  }


  /**
   * VintagesImages upsert
   */
  export type VintagesImagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the VintagesImages
    **/
    select?: VintagesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesImagesInclude | null
    /**
     * The filter to search for the VintagesImages to update in case it exists.
    **/
    where: VintagesImagesWhereUniqueInput
    /**
     * In case the VintagesImages found by the `where` argument doesn't exist, create a new VintagesImages with this data.
    **/
    create: VintagesImagesCreateInput
    /**
     * In case the VintagesImages was found with the provided `where` argument, update it with this data.
    **/
    update: VintagesImagesUpdateInput
  }


  /**
   * VintagesImages delete
   */
  export type VintagesImagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the VintagesImages
    **/
    select?: VintagesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesImagesInclude | null
    /**
     * Filter which VintagesImages to delete.
    **/
    where: VintagesImagesWhereUniqueInput
  }


  /**
   * VintagesImages deleteMany
   */
  export type VintagesImagesDeleteManyArgs = {
    where?: VintagesImagesWhereInput
  }


  /**
   * VintagesImages without action
   */
  export type VintagesImagesArgs = {
    /**
     * Select specific fields to fetch from the VintagesImages
    **/
    select?: VintagesImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: VintagesImagesInclude | null
  }



  /**
   * Model Reviews
   */


  export type AggregateReviews = {
    count: number | null
    avg: ReviewsAvgAggregateOutputType | null
    sum: ReviewsSumAggregateOutputType | null
    min: ReviewsMinAggregateOutputType | null
    max: ReviewsMaxAggregateOutputType | null
  }

  export type ReviewsAvgAggregateOutputType = {
    id: number
    star_review: number
    likes: number
    vintageID: number
  }

  export type ReviewsSumAggregateOutputType = {
    id: number
    star_review: number
    likes: number
    vintageID: number
  }

  export type ReviewsMinAggregateOutputType = {
    id: number
    user_id: string | null
    user_level: string | null
    user_review: string | null
    star_review: number
    timestamp: Date | null
    likes: number
    vintageID: number
  }

  export type ReviewsMaxAggregateOutputType = {
    id: number
    user_id: string | null
    user_level: string | null
    user_review: string | null
    star_review: number
    timestamp: Date | null
    likes: number
    vintageID: number
  }

  export type ReviewsCountAggregateOutputType = {
    id: number
    user_id: number | null
    user_level: number | null
    user_review: number | null
    star_review: number
    timestamp: number | null
    likes: number
    vintageID: number
    _all: number
  }


  export type ReviewsAvgAggregateInputType = {
    id?: true
    star_review?: true
    likes?: true
    vintageID?: true
  }

  export type ReviewsSumAggregateInputType = {
    id?: true
    star_review?: true
    likes?: true
    vintageID?: true
  }

  export type ReviewsMinAggregateInputType = {
    id?: true
    user_id?: true
    user_level?: true
    user_review?: true
    star_review?: true
    timestamp?: true
    likes?: true
    vintageID?: true
  }

  export type ReviewsMaxAggregateInputType = {
    id?: true
    user_id?: true
    user_level?: true
    user_review?: true
    star_review?: true
    timestamp?: true
    likes?: true
    vintageID?: true
  }

  export type ReviewsCountAggregateInputType = {
    id?: true
    user_id?: true
    user_level?: true
    user_review?: true
    star_review?: true
    timestamp?: true
    likes?: true
    vintageID?: true
    _all?: true
  }

  export type AggregateReviewsArgs = {
    where?: ReviewsWhereInput
    orderBy?: Enumerable<ReviewsOrderByInput>
    cursor?: ReviewsWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: ReviewsAvgAggregateInputType
    sum?: ReviewsSumAggregateInputType
    min?: ReviewsMinAggregateInputType
    max?: ReviewsMaxAggregateInputType
  }

  export type GetReviewsAggregateType<T extends AggregateReviewsArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetReviewsAggregateScalarType<T[P]>
  }

  export type GetReviewsAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof ReviewsAvgAggregateOutputType ? ReviewsAvgAggregateOutputType[P] : never
  }

    



  export type ReviewsSelect = {
    id?: boolean
    User?: boolean | UsersArgs
    user_id?: boolean
    user_level?: boolean
    user_review?: boolean
    star_review?: boolean
    timestamp?: boolean
    likes?: boolean
    vintageID?: boolean
    Vintages?: boolean | VintagesArgs
    images?: boolean | FindManyReviewsImagesArgs
  }

  export type ReviewsInclude = {
    User?: boolean | UsersArgs
    Vintages?: boolean | VintagesArgs
    images?: boolean | FindManyReviewsImagesArgs
  }

  export type ReviewsGetPayload<
    S extends boolean | null | undefined | ReviewsArgs,
    U = keyof S
      > = S extends true
        ? Reviews
    : S extends undefined
    ? never
    : S extends ReviewsArgs | FindManyReviewsArgs
    ?'include' extends U
    ? Reviews  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? UsersGetPayload<S['include'][P]> :
        P extends 'Vintages'
        ? VintagesGetPayload<S['include'][P]> :
        P extends 'images'
        ? Array < ReviewsImagesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Reviews ?Reviews [P]
  : 
          P extends 'User'
        ? UsersGetPayload<S['select'][P]> :
        P extends 'Vintages'
        ? VintagesGetPayload<S['select'][P]> :
        P extends 'images'
        ? Array < ReviewsImagesGetPayload<S['select'][P]>>  : never
  } 
    : Reviews
  : Reviews


  export interface ReviewsDelegate {
    /**
     * Find zero or one Reviews that matches the filter.
     * @param {FindUniqueReviewsArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueReviewsArgs>(
      args: Subset<T, FindUniqueReviewsArgs>
    ): CheckSelect<T, Prisma__ReviewsClient<Reviews | null>, Prisma__ReviewsClient<ReviewsGetPayload<T> | null>>
    /**
     * Find the first Reviews that matches the filter.
     * @param {FindFirstReviewsArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstReviewsArgs>(
      args?: Subset<T, FindFirstReviewsArgs>
    ): CheckSelect<T, Prisma__ReviewsClient<Reviews | null>, Prisma__ReviewsClient<ReviewsGetPayload<T> | null>>
    /**
     * Find zero or more Reviews that matches the filter.
     * @param {FindManyReviewsArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.reviews.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.reviews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewsWithIdOnly = await prisma.reviews.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyReviewsArgs>(
      args?: Subset<T, FindManyReviewsArgs>
    ): CheckSelect<T, Promise<Array<Reviews>>, Promise<Array<ReviewsGetPayload<T>>>>
    /**
     * Create a Reviews.
     * @param {ReviewsCreateArgs} args - Arguments to create a Reviews.
     * @example
     * // Create one Reviews
     * const Reviews = await prisma.reviews.create({
     *   data: {
     *     // ... data to create a Reviews
     *   }
     * })
     * 
    **/
    create<T extends ReviewsCreateArgs>(
      args: Subset<T, ReviewsCreateArgs>
    ): CheckSelect<T, Prisma__ReviewsClient<Reviews>, Prisma__ReviewsClient<ReviewsGetPayload<T>>>
    /**
     * Delete a Reviews.
     * @param {ReviewsDeleteArgs} args - Arguments to delete one Reviews.
     * @example
     * // Delete one Reviews
     * const Reviews = await prisma.reviews.delete({
     *   where: {
     *     // ... filter to delete one Reviews
     *   }
     * })
     * 
    **/
    delete<T extends ReviewsDeleteArgs>(
      args: Subset<T, ReviewsDeleteArgs>
    ): CheckSelect<T, Prisma__ReviewsClient<Reviews>, Prisma__ReviewsClient<ReviewsGetPayload<T>>>
    /**
     * Update one Reviews.
     * @param {ReviewsUpdateArgs} args - Arguments to update one Reviews.
     * @example
     * // Update one Reviews
     * const reviews = await prisma.reviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewsUpdateArgs>(
      args: Subset<T, ReviewsUpdateArgs>
    ): CheckSelect<T, Prisma__ReviewsClient<Reviews>, Prisma__ReviewsClient<ReviewsGetPayload<T>>>
    /**
     * Delete zero or more Reviews.
     * @param {ReviewsDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.reviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewsDeleteManyArgs>(
      args?: Subset<T, ReviewsDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Reviews.
     * @param {ReviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewsUpdateManyArgs>(
      args: Subset<T, ReviewsUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Reviews.
     * @param {ReviewsUpsertArgs} args - Arguments to update or create a Reviews.
     * @example
     * // Update or create a Reviews
     * const reviews = await prisma.reviews.upsert({
     *   create: {
     *     // ... data to create a Reviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviews we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewsUpsertArgs>(
      args: Subset<T, ReviewsUpsertArgs>
    ): CheckSelect<T, Prisma__ReviewsClient<Reviews>, Prisma__ReviewsClient<ReviewsGetPayload<T>>>
    /**
     * Find zero or one Reviews that matches the filter.
     * @param {FindUniqueReviewsArgs} args - Arguments to find a Reviews
     * @deprecated This will be deprecated please use prisma.reviews.findUnique
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueReviewsArgs>(
      args: Subset<T, FindUniqueReviewsArgs>
    ): CheckSelect<T, Prisma__ReviewsClient<Reviews | null>, Prisma__ReviewsClient<ReviewsGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyReviewsArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateReviewsArgs>(args: Subset<T, AggregateReviewsArgs>): Promise<GetReviewsAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReviewsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null>, Prisma__UsersClient<UsersGetPayload<T> | null>>;

    Vintages<T extends VintagesArgs = {}>(args?: Subset<T, VintagesArgs>): CheckSelect<T, Prisma__VintagesClient<Vintages | null>, Prisma__VintagesClient<VintagesGetPayload<T> | null>>;

    images<T extends FindManyReviewsImagesArgs = {}>(args?: Subset<T, FindManyReviewsImagesArgs>): CheckSelect<T, Promise<Array<ReviewsImages>>, Promise<Array<ReviewsImagesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Reviews findUnique
   */
  export type FindUniqueReviewsArgs = {
    /**
     * Select specific fields to fetch from the Reviews
    **/
    select?: ReviewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsInclude | null
    /**
     * Filter, which Reviews to fetch.
    **/
    where: ReviewsWhereUniqueInput
  }


  /**
   * Reviews findFirst
   */
  export type FindFirstReviewsArgs = {
    /**
     * Select specific fields to fetch from the Reviews
    **/
    select?: ReviewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsInclude | null
    /**
     * Filter, which Reviews to fetch.
    **/
    where?: ReviewsWhereInput
    orderBy?: Enumerable<ReviewsOrderByInput>
    cursor?: ReviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReviewsScalarFieldEnum>
  }


  /**
   * Reviews findMany
   */
  export type FindManyReviewsArgs = {
    /**
     * Select specific fields to fetch from the Reviews
    **/
    select?: ReviewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsInclude | null
    /**
     * Filter, which Reviews to fetch.
    **/
    where?: ReviewsWhereInput
    /**
     * Determine the order of the Reviews to fetch.
    **/
    orderBy?: Enumerable<ReviewsOrderByInput>
    /**
     * Sets the position for listing Reviews.
    **/
    cursor?: ReviewsWhereUniqueInput
    /**
     * The number of Reviews to fetch. If negative number, it will take Reviews before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` Reviews.
    **/
    skip?: number
    distinct?: Enumerable<ReviewsScalarFieldEnum>
  }


  /**
   * Reviews create
   */
  export type ReviewsCreateArgs = {
    /**
     * Select specific fields to fetch from the Reviews
    **/
    select?: ReviewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsInclude | null
    /**
     * The data needed to create a Reviews.
    **/
    data: ReviewsCreateInput
  }


  /**
   * Reviews update
   */
  export type ReviewsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Reviews
    **/
    select?: ReviewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsInclude | null
    /**
     * The data needed to update a Reviews.
    **/
    data: ReviewsUpdateInput
    /**
     * Choose, which Reviews to update.
    **/
    where: ReviewsWhereUniqueInput
  }


  /**
   * Reviews updateMany
   */
  export type ReviewsUpdateManyArgs = {
    data: ReviewsUpdateManyMutationInput
    where?: ReviewsWhereInput
  }


  /**
   * Reviews upsert
   */
  export type ReviewsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Reviews
    **/
    select?: ReviewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsInclude | null
    /**
     * The filter to search for the Reviews to update in case it exists.
    **/
    where: ReviewsWhereUniqueInput
    /**
     * In case the Reviews found by the `where` argument doesn't exist, create a new Reviews with this data.
    **/
    create: ReviewsCreateInput
    /**
     * In case the Reviews was found with the provided `where` argument, update it with this data.
    **/
    update: ReviewsUpdateInput
  }


  /**
   * Reviews delete
   */
  export type ReviewsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Reviews
    **/
    select?: ReviewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsInclude | null
    /**
     * Filter which Reviews to delete.
    **/
    where: ReviewsWhereUniqueInput
  }


  /**
   * Reviews deleteMany
   */
  export type ReviewsDeleteManyArgs = {
    where?: ReviewsWhereInput
  }


  /**
   * Reviews without action
   */
  export type ReviewsArgs = {
    /**
     * Select specific fields to fetch from the Reviews
    **/
    select?: ReviewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsInclude | null
  }



  /**
   * Model ReviewsImages
   */


  export type AggregateReviewsImages = {
    count: number | null
    avg: ReviewsImagesAvgAggregateOutputType | null
    sum: ReviewsImagesSumAggregateOutputType | null
    min: ReviewsImagesMinAggregateOutputType | null
    max: ReviewsImagesMaxAggregateOutputType | null
  }

  export type ReviewsImagesAvgAggregateOutputType = {
    id: number
    reviewsID: number
  }

  export type ReviewsImagesSumAggregateOutputType = {
    id: number
    reviewsID: number
  }

  export type ReviewsImagesMinAggregateOutputType = {
    id: number
    reviewsID: number
    imageLink: string | null
  }

  export type ReviewsImagesMaxAggregateOutputType = {
    id: number
    reviewsID: number
    imageLink: string | null
  }

  export type ReviewsImagesCountAggregateOutputType = {
    id: number
    reviewsID: number
    imageLink: number | null
    _all: number
  }


  export type ReviewsImagesAvgAggregateInputType = {
    id?: true
    reviewsID?: true
  }

  export type ReviewsImagesSumAggregateInputType = {
    id?: true
    reviewsID?: true
  }

  export type ReviewsImagesMinAggregateInputType = {
    id?: true
    reviewsID?: true
    imageLink?: true
  }

  export type ReviewsImagesMaxAggregateInputType = {
    id?: true
    reviewsID?: true
    imageLink?: true
  }

  export type ReviewsImagesCountAggregateInputType = {
    id?: true
    reviewsID?: true
    imageLink?: true
    _all?: true
  }

  export type AggregateReviewsImagesArgs = {
    where?: ReviewsImagesWhereInput
    orderBy?: Enumerable<ReviewsImagesOrderByInput>
    cursor?: ReviewsImagesWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: ReviewsImagesAvgAggregateInputType
    sum?: ReviewsImagesSumAggregateInputType
    min?: ReviewsImagesMinAggregateInputType
    max?: ReviewsImagesMaxAggregateInputType
  }

  export type GetReviewsImagesAggregateType<T extends AggregateReviewsImagesArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetReviewsImagesAggregateScalarType<T[P]>
  }

  export type GetReviewsImagesAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof ReviewsImagesAvgAggregateOutputType ? ReviewsImagesAvgAggregateOutputType[P] : never
  }

    



  export type ReviewsImagesSelect = {
    id?: boolean
    reviewsID?: boolean
    imageLink?: boolean
    Reviews?: boolean | ReviewsArgs
  }

  export type ReviewsImagesInclude = {
    Reviews?: boolean | ReviewsArgs
  }

  export type ReviewsImagesGetPayload<
    S extends boolean | null | undefined | ReviewsImagesArgs,
    U = keyof S
      > = S extends true
        ? ReviewsImages
    : S extends undefined
    ? never
    : S extends ReviewsImagesArgs | FindManyReviewsImagesArgs
    ?'include' extends U
    ? ReviewsImages  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Reviews'
        ? ReviewsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ReviewsImages ?ReviewsImages [P]
  : 
          P extends 'Reviews'
        ? ReviewsGetPayload<S['select'][P]> : never
  } 
    : ReviewsImages
  : ReviewsImages


  export interface ReviewsImagesDelegate {
    /**
     * Find zero or one ReviewsImages that matches the filter.
     * @param {FindUniqueReviewsImagesArgs} args - Arguments to find a ReviewsImages
     * @example
     * // Get one ReviewsImages
     * const reviewsImages = await prisma.reviewsImages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueReviewsImagesArgs>(
      args: Subset<T, FindUniqueReviewsImagesArgs>
    ): CheckSelect<T, Prisma__ReviewsImagesClient<ReviewsImages | null>, Prisma__ReviewsImagesClient<ReviewsImagesGetPayload<T> | null>>
    /**
     * Find the first ReviewsImages that matches the filter.
     * @param {FindFirstReviewsImagesArgs} args - Arguments to find a ReviewsImages
     * @example
     * // Get one ReviewsImages
     * const reviewsImages = await prisma.reviewsImages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstReviewsImagesArgs>(
      args?: Subset<T, FindFirstReviewsImagesArgs>
    ): CheckSelect<T, Prisma__ReviewsImagesClient<ReviewsImages | null>, Prisma__ReviewsImagesClient<ReviewsImagesGetPayload<T> | null>>
    /**
     * Find zero or more ReviewsImages that matches the filter.
     * @param {FindManyReviewsImagesArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewsImages
     * const reviewsImages = await prisma.reviewsImages.findMany()
     * 
     * // Get first 10 ReviewsImages
     * const reviewsImages = await prisma.reviewsImages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewsImagesWithIdOnly = await prisma.reviewsImages.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyReviewsImagesArgs>(
      args?: Subset<T, FindManyReviewsImagesArgs>
    ): CheckSelect<T, Promise<Array<ReviewsImages>>, Promise<Array<ReviewsImagesGetPayload<T>>>>
    /**
     * Create a ReviewsImages.
     * @param {ReviewsImagesCreateArgs} args - Arguments to create a ReviewsImages.
     * @example
     * // Create one ReviewsImages
     * const ReviewsImages = await prisma.reviewsImages.create({
     *   data: {
     *     // ... data to create a ReviewsImages
     *   }
     * })
     * 
    **/
    create<T extends ReviewsImagesCreateArgs>(
      args: Subset<T, ReviewsImagesCreateArgs>
    ): CheckSelect<T, Prisma__ReviewsImagesClient<ReviewsImages>, Prisma__ReviewsImagesClient<ReviewsImagesGetPayload<T>>>
    /**
     * Delete a ReviewsImages.
     * @param {ReviewsImagesDeleteArgs} args - Arguments to delete one ReviewsImages.
     * @example
     * // Delete one ReviewsImages
     * const ReviewsImages = await prisma.reviewsImages.delete({
     *   where: {
     *     // ... filter to delete one ReviewsImages
     *   }
     * })
     * 
    **/
    delete<T extends ReviewsImagesDeleteArgs>(
      args: Subset<T, ReviewsImagesDeleteArgs>
    ): CheckSelect<T, Prisma__ReviewsImagesClient<ReviewsImages>, Prisma__ReviewsImagesClient<ReviewsImagesGetPayload<T>>>
    /**
     * Update one ReviewsImages.
     * @param {ReviewsImagesUpdateArgs} args - Arguments to update one ReviewsImages.
     * @example
     * // Update one ReviewsImages
     * const reviewsImages = await prisma.reviewsImages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewsImagesUpdateArgs>(
      args: Subset<T, ReviewsImagesUpdateArgs>
    ): CheckSelect<T, Prisma__ReviewsImagesClient<ReviewsImages>, Prisma__ReviewsImagesClient<ReviewsImagesGetPayload<T>>>
    /**
     * Delete zero or more ReviewsImages.
     * @param {ReviewsImagesDeleteManyArgs} args - Arguments to filter ReviewsImages to delete.
     * @example
     * // Delete a few ReviewsImages
     * const { count } = await prisma.reviewsImages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewsImagesDeleteManyArgs>(
      args?: Subset<T, ReviewsImagesDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more ReviewsImages.
     * @param {ReviewsImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewsImages
     * const reviewsImages = await prisma.reviewsImages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewsImagesUpdateManyArgs>(
      args: Subset<T, ReviewsImagesUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one ReviewsImages.
     * @param {ReviewsImagesUpsertArgs} args - Arguments to update or create a ReviewsImages.
     * @example
     * // Update or create a ReviewsImages
     * const reviewsImages = await prisma.reviewsImages.upsert({
     *   create: {
     *     // ... data to create a ReviewsImages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewsImages we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewsImagesUpsertArgs>(
      args: Subset<T, ReviewsImagesUpsertArgs>
    ): CheckSelect<T, Prisma__ReviewsImagesClient<ReviewsImages>, Prisma__ReviewsImagesClient<ReviewsImagesGetPayload<T>>>
    /**
     * Find zero or one ReviewsImages that matches the filter.
     * @param {FindUniqueReviewsImagesArgs} args - Arguments to find a ReviewsImages
     * @deprecated This will be deprecated please use prisma.reviewsImages.findUnique
     * @example
     * // Get one ReviewsImages
     * const reviewsImages = await prisma.reviewsImages.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueReviewsImagesArgs>(
      args: Subset<T, FindUniqueReviewsImagesArgs>
    ): CheckSelect<T, Prisma__ReviewsImagesClient<ReviewsImages | null>, Prisma__ReviewsImagesClient<ReviewsImagesGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyReviewsImagesArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateReviewsImagesArgs>(args: Subset<T, AggregateReviewsImagesArgs>): Promise<GetReviewsImagesAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewsImages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReviewsImagesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Reviews<T extends ReviewsArgs = {}>(args?: Subset<T, ReviewsArgs>): CheckSelect<T, Prisma__ReviewsClient<Reviews | null>, Prisma__ReviewsClient<ReviewsGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ReviewsImages findUnique
   */
  export type FindUniqueReviewsImagesArgs = {
    /**
     * Select specific fields to fetch from the ReviewsImages
    **/
    select?: ReviewsImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsImagesInclude | null
    /**
     * Filter, which ReviewsImages to fetch.
    **/
    where: ReviewsImagesWhereUniqueInput
  }


  /**
   * ReviewsImages findFirst
   */
  export type FindFirstReviewsImagesArgs = {
    /**
     * Select specific fields to fetch from the ReviewsImages
    **/
    select?: ReviewsImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsImagesInclude | null
    /**
     * Filter, which ReviewsImages to fetch.
    **/
    where?: ReviewsImagesWhereInput
    orderBy?: Enumerable<ReviewsImagesOrderByInput>
    cursor?: ReviewsImagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReviewsImagesScalarFieldEnum>
  }


  /**
   * ReviewsImages findMany
   */
  export type FindManyReviewsImagesArgs = {
    /**
     * Select specific fields to fetch from the ReviewsImages
    **/
    select?: ReviewsImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsImagesInclude | null
    /**
     * Filter, which ReviewsImages to fetch.
    **/
    where?: ReviewsImagesWhereInput
    /**
     * Determine the order of the ReviewsImages to fetch.
    **/
    orderBy?: Enumerable<ReviewsImagesOrderByInput>
    /**
     * Sets the position for listing ReviewsImages.
    **/
    cursor?: ReviewsImagesWhereUniqueInput
    /**
     * The number of ReviewsImages to fetch. If negative number, it will take ReviewsImages before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` ReviewsImages.
    **/
    skip?: number
    distinct?: Enumerable<ReviewsImagesScalarFieldEnum>
  }


  /**
   * ReviewsImages create
   */
  export type ReviewsImagesCreateArgs = {
    /**
     * Select specific fields to fetch from the ReviewsImages
    **/
    select?: ReviewsImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsImagesInclude | null
    /**
     * The data needed to create a ReviewsImages.
    **/
    data: ReviewsImagesCreateInput
  }


  /**
   * ReviewsImages update
   */
  export type ReviewsImagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReviewsImages
    **/
    select?: ReviewsImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsImagesInclude | null
    /**
     * The data needed to update a ReviewsImages.
    **/
    data: ReviewsImagesUpdateInput
    /**
     * Choose, which ReviewsImages to update.
    **/
    where: ReviewsImagesWhereUniqueInput
  }


  /**
   * ReviewsImages updateMany
   */
  export type ReviewsImagesUpdateManyArgs = {
    data: ReviewsImagesUpdateManyMutationInput
    where?: ReviewsImagesWhereInput
  }


  /**
   * ReviewsImages upsert
   */
  export type ReviewsImagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReviewsImages
    **/
    select?: ReviewsImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsImagesInclude | null
    /**
     * The filter to search for the ReviewsImages to update in case it exists.
    **/
    where: ReviewsImagesWhereUniqueInput
    /**
     * In case the ReviewsImages found by the `where` argument doesn't exist, create a new ReviewsImages with this data.
    **/
    create: ReviewsImagesCreateInput
    /**
     * In case the ReviewsImages was found with the provided `where` argument, update it with this data.
    **/
    update: ReviewsImagesUpdateInput
  }


  /**
   * ReviewsImages delete
   */
  export type ReviewsImagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReviewsImages
    **/
    select?: ReviewsImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsImagesInclude | null
    /**
     * Filter which ReviewsImages to delete.
    **/
    where: ReviewsImagesWhereUniqueInput
  }


  /**
   * ReviewsImages deleteMany
   */
  export type ReviewsImagesDeleteManyArgs = {
    where?: ReviewsImagesWhereInput
  }


  /**
   * ReviewsImages without action
   */
  export type ReviewsImagesArgs = {
    /**
     * Select specific fields to fetch from the ReviewsImages
    **/
    select?: ReviewsImagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewsImagesInclude | null
  }



  /**
   * Model User_Accounts
   */


  export type AggregateUser_Accounts = {
    count: number | null
    min: User_AccountsMinAggregateOutputType | null
    max: User_AccountsMaxAggregateOutputType | null
  }

  export type User_AccountsMinAggregateOutputType = {
    id: string | null
    hash: string | null
    email: string | null
    creation_Date: Date | null
  }

  export type User_AccountsMaxAggregateOutputType = {
    id: string | null
    hash: string | null
    email: string | null
    creation_Date: Date | null
  }

  export type User_AccountsCountAggregateOutputType = {
    id: number | null
    hash: number | null
    email: number | null
    creation_Date: number | null
    _all: number
  }


  export type User_AccountsMinAggregateInputType = {
    id?: true
    hash?: true
    email?: true
    creation_Date?: true
  }

  export type User_AccountsMaxAggregateInputType = {
    id?: true
    hash?: true
    email?: true
    creation_Date?: true
  }

  export type User_AccountsCountAggregateInputType = {
    id?: true
    hash?: true
    email?: true
    creation_Date?: true
    _all?: true
  }

  export type AggregateUser_AccountsArgs = {
    where?: User_AccountsWhereInput
    orderBy?: Enumerable<User_AccountsOrderByInput>
    cursor?: User_AccountsWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    min?: User_AccountsMinAggregateInputType
    max?: User_AccountsMaxAggregateInputType
  }

  export type GetUser_AccountsAggregateType<T extends AggregateUser_AccountsArgs> = {
    [P in keyof T]: P extends 'count' ? number : never
  }



    



  export type User_AccountsSelect = {
    id?: boolean
    hash?: boolean
    email?: boolean
    creation_Date?: boolean
    user?: boolean | UsersArgs
  }

  export type User_AccountsInclude = {
    user?: boolean | UsersArgs
  }

  export type User_AccountsGetPayload<
    S extends boolean | null | undefined | User_AccountsArgs,
    U = keyof S
      > = S extends true
        ? User_Accounts
    : S extends undefined
    ? never
    : S extends User_AccountsArgs | FindManyUser_AccountsArgs
    ?'include' extends U
    ? User_Accounts  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UsersGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User_Accounts ?User_Accounts [P]
  : 
          P extends 'user'
        ? UsersGetPayload<S['select'][P]> | null : never
  } 
    : User_Accounts
  : User_Accounts


  export interface User_AccountsDelegate {
    /**
     * Find zero or one User_Accounts that matches the filter.
     * @param {FindUniqueUser_AccountsArgs} args - Arguments to find a User_Accounts
     * @example
     * // Get one User_Accounts
     * const user_Accounts = await prisma.user_Accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueUser_AccountsArgs>(
      args: Subset<T, FindUniqueUser_AccountsArgs>
    ): CheckSelect<T, Prisma__User_AccountsClient<User_Accounts | null>, Prisma__User_AccountsClient<User_AccountsGetPayload<T> | null>>
    /**
     * Find the first User_Accounts that matches the filter.
     * @param {FindFirstUser_AccountsArgs} args - Arguments to find a User_Accounts
     * @example
     * // Get one User_Accounts
     * const user_Accounts = await prisma.user_Accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstUser_AccountsArgs>(
      args?: Subset<T, FindFirstUser_AccountsArgs>
    ): CheckSelect<T, Prisma__User_AccountsClient<User_Accounts | null>, Prisma__User_AccountsClient<User_AccountsGetPayload<T> | null>>
    /**
     * Find zero or more User_Accounts that matches the filter.
     * @param {FindManyUser_AccountsArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_Accounts
     * const user_Accounts = await prisma.user_Accounts.findMany()
     * 
     * // Get first 10 User_Accounts
     * const user_Accounts = await prisma.user_Accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_AccountsWithIdOnly = await prisma.user_Accounts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyUser_AccountsArgs>(
      args?: Subset<T, FindManyUser_AccountsArgs>
    ): CheckSelect<T, Promise<Array<User_Accounts>>, Promise<Array<User_AccountsGetPayload<T>>>>
    /**
     * Create a User_Accounts.
     * @param {User_AccountsCreateArgs} args - Arguments to create a User_Accounts.
     * @example
     * // Create one User_Accounts
     * const User_Accounts = await prisma.user_Accounts.create({
     *   data: {
     *     // ... data to create a User_Accounts
     *   }
     * })
     * 
    **/
    create<T extends User_AccountsCreateArgs>(
      args: Subset<T, User_AccountsCreateArgs>
    ): CheckSelect<T, Prisma__User_AccountsClient<User_Accounts>, Prisma__User_AccountsClient<User_AccountsGetPayload<T>>>
    /**
     * Delete a User_Accounts.
     * @param {User_AccountsDeleteArgs} args - Arguments to delete one User_Accounts.
     * @example
     * // Delete one User_Accounts
     * const User_Accounts = await prisma.user_Accounts.delete({
     *   where: {
     *     // ... filter to delete one User_Accounts
     *   }
     * })
     * 
    **/
    delete<T extends User_AccountsDeleteArgs>(
      args: Subset<T, User_AccountsDeleteArgs>
    ): CheckSelect<T, Prisma__User_AccountsClient<User_Accounts>, Prisma__User_AccountsClient<User_AccountsGetPayload<T>>>
    /**
     * Update one User_Accounts.
     * @param {User_AccountsUpdateArgs} args - Arguments to update one User_Accounts.
     * @example
     * // Update one User_Accounts
     * const user_Accounts = await prisma.user_Accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends User_AccountsUpdateArgs>(
      args: Subset<T, User_AccountsUpdateArgs>
    ): CheckSelect<T, Prisma__User_AccountsClient<User_Accounts>, Prisma__User_AccountsClient<User_AccountsGetPayload<T>>>
    /**
     * Delete zero or more User_Accounts.
     * @param {User_AccountsDeleteManyArgs} args - Arguments to filter User_Accounts to delete.
     * @example
     * // Delete a few User_Accounts
     * const { count } = await prisma.user_Accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends User_AccountsDeleteManyArgs>(
      args?: Subset<T, User_AccountsDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more User_Accounts.
     * @param {User_AccountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_Accounts
     * const user_Accounts = await prisma.user_Accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends User_AccountsUpdateManyArgs>(
      args: Subset<T, User_AccountsUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one User_Accounts.
     * @param {User_AccountsUpsertArgs} args - Arguments to update or create a User_Accounts.
     * @example
     * // Update or create a User_Accounts
     * const user_Accounts = await prisma.user_Accounts.upsert({
     *   create: {
     *     // ... data to create a User_Accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_Accounts we want to update
     *   }
     * })
    **/
    upsert<T extends User_AccountsUpsertArgs>(
      args: Subset<T, User_AccountsUpsertArgs>
    ): CheckSelect<T, Prisma__User_AccountsClient<User_Accounts>, Prisma__User_AccountsClient<User_AccountsGetPayload<T>>>
    /**
     * Find zero or one User_Accounts that matches the filter.
     * @param {FindUniqueUser_AccountsArgs} args - Arguments to find a User_Accounts
     * @deprecated This will be deprecated please use prisma.user_Accounts.findUnique
     * @example
     * // Get one User_Accounts
     * const user_Accounts = await prisma.user_Accounts.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueUser_AccountsArgs>(
      args: Subset<T, FindUniqueUser_AccountsArgs>
    ): CheckSelect<T, Prisma__User_AccountsClient<User_Accounts | null>, Prisma__User_AccountsClient<User_AccountsGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyUser_AccountsArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateUser_AccountsArgs>(args: Subset<T, AggregateUser_AccountsArgs>): Promise<GetUser_AccountsAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User_Accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__User_AccountsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null>, Prisma__UsersClient<UsersGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User_Accounts findUnique
   */
  export type FindUniqueUser_AccountsArgs = {
    /**
     * Select specific fields to fetch from the User_Accounts
    **/
    select?: User_AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: User_AccountsInclude | null
    /**
     * Filter, which User_Accounts to fetch.
    **/
    where: User_AccountsWhereUniqueInput
  }


  /**
   * User_Accounts findFirst
   */
  export type FindFirstUser_AccountsArgs = {
    /**
     * Select specific fields to fetch from the User_Accounts
    **/
    select?: User_AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: User_AccountsInclude | null
    /**
     * Filter, which User_Accounts to fetch.
    **/
    where?: User_AccountsWhereInput
    orderBy?: Enumerable<User_AccountsOrderByInput>
    cursor?: User_AccountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_AccountsScalarFieldEnum>
  }


  /**
   * User_Accounts findMany
   */
  export type FindManyUser_AccountsArgs = {
    /**
     * Select specific fields to fetch from the User_Accounts
    **/
    select?: User_AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: User_AccountsInclude | null
    /**
     * Filter, which User_Accounts to fetch.
    **/
    where?: User_AccountsWhereInput
    /**
     * Determine the order of the User_Accounts to fetch.
    **/
    orderBy?: Enumerable<User_AccountsOrderByInput>
    /**
     * Sets the position for listing User_Accounts.
    **/
    cursor?: User_AccountsWhereUniqueInput
    /**
     * The number of User_Accounts to fetch. If negative number, it will take User_Accounts before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` User_Accounts.
    **/
    skip?: number
    distinct?: Enumerable<User_AccountsScalarFieldEnum>
  }


  /**
   * User_Accounts create
   */
  export type User_AccountsCreateArgs = {
    /**
     * Select specific fields to fetch from the User_Accounts
    **/
    select?: User_AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: User_AccountsInclude | null
    /**
     * The data needed to create a User_Accounts.
    **/
    data: User_AccountsCreateInput
  }


  /**
   * User_Accounts update
   */
  export type User_AccountsUpdateArgs = {
    /**
     * Select specific fields to fetch from the User_Accounts
    **/
    select?: User_AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: User_AccountsInclude | null
    /**
     * The data needed to update a User_Accounts.
    **/
    data: User_AccountsUpdateInput
    /**
     * Choose, which User_Accounts to update.
    **/
    where: User_AccountsWhereUniqueInput
  }


  /**
   * User_Accounts updateMany
   */
  export type User_AccountsUpdateManyArgs = {
    data: User_AccountsUpdateManyMutationInput
    where?: User_AccountsWhereInput
  }


  /**
   * User_Accounts upsert
   */
  export type User_AccountsUpsertArgs = {
    /**
     * Select specific fields to fetch from the User_Accounts
    **/
    select?: User_AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: User_AccountsInclude | null
    /**
     * The filter to search for the User_Accounts to update in case it exists.
    **/
    where: User_AccountsWhereUniqueInput
    /**
     * In case the User_Accounts found by the `where` argument doesn't exist, create a new User_Accounts with this data.
    **/
    create: User_AccountsCreateInput
    /**
     * In case the User_Accounts was found with the provided `where` argument, update it with this data.
    **/
    update: User_AccountsUpdateInput
  }


  /**
   * User_Accounts delete
   */
  export type User_AccountsDeleteArgs = {
    /**
     * Select specific fields to fetch from the User_Accounts
    **/
    select?: User_AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: User_AccountsInclude | null
    /**
     * Filter which User_Accounts to delete.
    **/
    where: User_AccountsWhereUniqueInput
  }


  /**
   * User_Accounts deleteMany
   */
  export type User_AccountsDeleteManyArgs = {
    where?: User_AccountsWhereInput
  }


  /**
   * User_Accounts without action
   */
  export type User_AccountsArgs = {
    /**
     * Select specific fields to fetch from the User_Accounts
    **/
    select?: User_AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: User_AccountsInclude | null
  }



  /**
   * Model Users
   */


  export type AggregateUsers = {
    count: number | null
    min: UsersMinAggregateOutputType | null
    max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    first_name: string | null
    last_name: string | null
    new_user: boolean | null
    account_ID: string | null
    user_img: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    first_name: string | null
    last_name: string | null
    new_user: boolean | null
    account_ID: string | null
    user_img: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number | null
    first_name: number | null
    last_name: number | null
    new_user: number | null
    account_ID: number | null
    user_img: number | null
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    new_user?: true
    account_ID?: true
    user_img?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    new_user?: true
    account_ID?: true
    user_img?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    new_user?: true
    account_ID?: true
    user_img?: true
    _all?: true
  }

  export type AggregateUsersArgs = {
    where?: UsersWhereInput
    orderBy?: Enumerable<UsersOrderByInput>
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    min?: UsersMinAggregateInputType
    max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends AggregateUsersArgs> = {
    [P in keyof T]: P extends 'count' ? number : never
  }



    



  export type UsersSelect = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    new_user?: boolean
    account_ID?: boolean
    user_img?: boolean
    account?: boolean | User_AccountsArgs
    reviews?: boolean | FindManyReviewsArgs
  }

  export type UsersInclude = {
    account?: boolean | User_AccountsArgs
    reviews?: boolean | FindManyReviewsArgs
  }

  export type UsersGetPayload<
    S extends boolean | null | undefined | UsersArgs,
    U = keyof S
      > = S extends true
        ? Users
    : S extends undefined
    ? never
    : S extends UsersArgs | FindManyUsersArgs
    ?'include' extends U
    ? Users  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'account'
        ? User_AccountsGetPayload<S['include'][P]> :
        P extends 'reviews'
        ? Array < ReviewsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Users ?Users [P]
  : 
          P extends 'account'
        ? User_AccountsGetPayload<S['select'][P]> :
        P extends 'reviews'
        ? Array < ReviewsGetPayload<S['select'][P]>>  : never
  } 
    : Users
  : Users


  export interface UsersDelegate {
    /**
     * Find zero or one Users that matches the filter.
     * @param {FindUniqueUsersArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueUsersArgs>(
      args: Subset<T, FindUniqueUsersArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users | null>, Prisma__UsersClient<UsersGetPayload<T> | null>>
    /**
     * Find the first Users that matches the filter.
     * @param {FindFirstUsersArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstUsersArgs>(
      args?: Subset<T, FindFirstUsersArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users | null>, Prisma__UsersClient<UsersGetPayload<T> | null>>
    /**
     * Find zero or more Users that matches the filter.
     * @param {FindManyUsersArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyUsersArgs>(
      args?: Subset<T, FindManyUsersArgs>
    ): CheckSelect<T, Promise<Array<Users>>, Promise<Array<UsersGetPayload<T>>>>
    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends UsersCreateArgs>(
      args: Subset<T, UsersCreateArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>
    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends UsersDeleteArgs>(
      args: Subset<T, UsersDeleteArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>
    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersUpdateArgs>(
      args: Subset<T, UsersUpdateArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>
    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersDeleteManyArgs>(
      args?: Subset<T, UsersDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Users.
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersUpdateManyArgs>(
      args: Subset<T, UsersUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends UsersUpsertArgs>(
      args: Subset<T, UsersUpsertArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>
    /**
     * Find zero or one Users that matches the filter.
     * @param {FindUniqueUsersArgs} args - Arguments to find a Users
     * @deprecated This will be deprecated please use prisma.users.findUnique
     * @example
     * // Get one Users
     * const users = await prisma.users.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueUsersArgs>(
      args: Subset<T, FindUniqueUsersArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users | null>, Prisma__UsersClient<UsersGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyUsersArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateUsersArgs>(args: Subset<T, AggregateUsersArgs>): Promise<GetUsersAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsersClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account<T extends User_AccountsArgs = {}>(args?: Subset<T, User_AccountsArgs>): CheckSelect<T, Prisma__User_AccountsClient<User_Accounts | null>, Prisma__User_AccountsClient<User_AccountsGetPayload<T> | null>>;

    reviews<T extends FindManyReviewsArgs = {}>(args?: Subset<T, FindManyReviewsArgs>): CheckSelect<T, Promise<Array<Reviews>>, Promise<Array<ReviewsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Users findUnique
   */
  export type FindUniqueUsersArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where: UsersWhereUniqueInput
  }


  /**
   * Users findFirst
   */
  export type FindFirstUsersArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where?: UsersWhereInput
    orderBy?: Enumerable<UsersOrderByInput>
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * Users findMany
   */
  export type FindManyUsersArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where?: UsersWhereInput
    /**
     * Determine the order of the Users to fetch.
    **/
    orderBy?: Enumerable<UsersOrderByInput>
    /**
     * Sets the position for listing Users.
    **/
    cursor?: UsersWhereUniqueInput
    /**
     * The number of Users to fetch. If negative number, it will take Users before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` Users.
    **/
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * Users create
   */
  export type UsersCreateArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * The data needed to create a Users.
    **/
    data: UsersCreateInput
  }


  /**
   * Users update
   */
  export type UsersUpdateArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * The data needed to update a Users.
    **/
    data: UsersUpdateInput
    /**
     * Choose, which Users to update.
    **/
    where: UsersWhereUniqueInput
  }


  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs = {
    data: UsersUpdateManyMutationInput
    where?: UsersWhereInput
  }


  /**
   * Users upsert
   */
  export type UsersUpsertArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * The filter to search for the Users to update in case it exists.
    **/
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
    **/
    create: UsersCreateInput
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
    **/
    update: UsersUpdateInput
  }


  /**
   * Users delete
   */
  export type UsersDeleteArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * Filter which Users to delete.
    **/
    where: UsersWhereUniqueInput
  }


  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs = {
    where?: UsersWhereInput
  }


  /**
   * Users without action
   */
  export type UsersArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const WineriesScalarFieldEnum: {
    id: 'id',
    winery_name: 'winery_name',
    winery_address: 'winery_address',
    winery_desc: 'winery_desc',
    coordinates: 'coordinates'
  };

  export type WineriesScalarFieldEnum = (typeof WineriesScalarFieldEnum)[keyof typeof WineriesScalarFieldEnum]


  export const WineriesImagesScalarFieldEnum: {
    id: 'id',
    wineryID: 'wineryID',
    imageLink: 'imageLink'
  };

  export type WineriesImagesScalarFieldEnum = (typeof WineriesImagesScalarFieldEnum)[keyof typeof WineriesImagesScalarFieldEnum]


  export const VintagesScalarFieldEnum: {
    id: 'id',
    vintage_name: 'vintage_name',
    vintage_year: 'vintage_year',
    assoc_winery: 'assoc_winery',
    description: 'description'
  };

  export type VintagesScalarFieldEnum = (typeof VintagesScalarFieldEnum)[keyof typeof VintagesScalarFieldEnum]


  export const VintagesImagesScalarFieldEnum: {
    id: 'id',
    vintagesID: 'vintagesID',
    imageLink: 'imageLink'
  };

  export type VintagesImagesScalarFieldEnum = (typeof VintagesImagesScalarFieldEnum)[keyof typeof VintagesImagesScalarFieldEnum]


  export const ReviewsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    user_level: 'user_level',
    user_review: 'user_review',
    star_review: 'star_review',
    timestamp: 'timestamp',
    likes: 'likes',
    vintageID: 'vintageID'
  };

  export type ReviewsScalarFieldEnum = (typeof ReviewsScalarFieldEnum)[keyof typeof ReviewsScalarFieldEnum]


  export const ReviewsImagesScalarFieldEnum: {
    id: 'id',
    reviewsID: 'reviewsID',
    imageLink: 'imageLink'
  };

  export type ReviewsImagesScalarFieldEnum = (typeof ReviewsImagesScalarFieldEnum)[keyof typeof ReviewsImagesScalarFieldEnum]


  export const User_AccountsScalarFieldEnum: {
    id: 'id',
    hash: 'hash',
    email: 'email',
    creation_Date: 'creation_Date'
  };

  export type User_AccountsScalarFieldEnum = (typeof User_AccountsScalarFieldEnum)[keyof typeof User_AccountsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    new_user: 'new_user',
    account_ID: 'account_ID',
    user_img: 'user_img'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type WineriesWhereInput = {
    AND?: Enumerable<WineriesWhereInput>
    OR?: Enumerable<WineriesWhereInput>
    NOT?: Enumerable<WineriesWhereInput>
    id?: IntFilter | number
    winery_name?: StringFilter | string
    winery_address?: StringFilter | string
    winery_desc?: StringFilter | string
    coordinates?: StringFilter | string
    Vintages?: VintagesListRelationFilter
    image?: WineriesImagesListRelationFilter
  }

  export type WineriesOrderByInput = {
    id?: SortOrder
    winery_name?: SortOrder
    winery_address?: SortOrder
    winery_desc?: SortOrder
    coordinates?: SortOrder
  }

  export type WineriesWhereUniqueInput = {
    id?: number
  }

  export type WineriesImagesWhereInput = {
    AND?: Enumerable<WineriesImagesWhereInput>
    OR?: Enumerable<WineriesImagesWhereInput>
    NOT?: Enumerable<WineriesImagesWhereInput>
    id?: IntFilter | number
    wineryID?: IntFilter | number
    imageLink?: StringFilter | string
    Wineries?: XOR<WineriesWhereInput, WineriesRelationFilter>
  }

  export type WineriesImagesOrderByInput = {
    id?: SortOrder
    wineryID?: SortOrder
    imageLink?: SortOrder
  }

  export type WineriesImagesWhereUniqueInput = {
    id?: number
  }

  export type VintagesWhereInput = {
    AND?: Enumerable<VintagesWhereInput>
    OR?: Enumerable<VintagesWhereInput>
    NOT?: Enumerable<VintagesWhereInput>
    id?: IntFilter | number
    vintage_name?: StringFilter | string
    vintage_year?: StringFilter | string
    assoc_winery?: IntFilter | number
    description?: StringFilter | string
    Wineries?: XOR<WineriesWhereInput, WineriesRelationFilter>
    Reviews?: ReviewsListRelationFilter
    images?: VintagesImagesListRelationFilter
  }

  export type VintagesOrderByInput = {
    id?: SortOrder
    vintage_name?: SortOrder
    vintage_year?: SortOrder
    assoc_winery?: SortOrder
    description?: SortOrder
  }

  export type VintagesWhereUniqueInput = {
    id?: number
  }

  export type VintagesImagesWhereInput = {
    AND?: Enumerable<VintagesImagesWhereInput>
    OR?: Enumerable<VintagesImagesWhereInput>
    NOT?: Enumerable<VintagesImagesWhereInput>
    id?: IntFilter | number
    vintagesID?: IntFilter | number
    imageLink?: StringFilter | string
    Vintages?: XOR<VintagesWhereInput, VintagesRelationFilter>
  }

  export type VintagesImagesOrderByInput = {
    id?: SortOrder
    vintagesID?: SortOrder
    imageLink?: SortOrder
  }

  export type VintagesImagesWhereUniqueInput = {
    id?: number
  }

  export type ReviewsWhereInput = {
    AND?: Enumerable<ReviewsWhereInput>
    OR?: Enumerable<ReviewsWhereInput>
    NOT?: Enumerable<ReviewsWhereInput>
    id?: IntFilter | number
    User?: XOR<UsersWhereInput, UsersRelationFilter>
    user_id?: StringFilter | string
    user_level?: StringFilter | string
    user_review?: StringFilter | string
    star_review?: IntFilter | number
    timestamp?: DateTimeFilter | Date | string
    likes?: IntFilter | number
    vintageID?: IntFilter | number
    Vintages?: XOR<VintagesWhereInput, VintagesRelationFilter>
    images?: ReviewsImagesListRelationFilter
  }

  export type ReviewsOrderByInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_level?: SortOrder
    user_review?: SortOrder
    star_review?: SortOrder
    timestamp?: SortOrder
    likes?: SortOrder
    vintageID?: SortOrder
  }

  export type ReviewsWhereUniqueInput = {
    id?: number
  }

  export type ReviewsImagesWhereInput = {
    AND?: Enumerable<ReviewsImagesWhereInput>
    OR?: Enumerable<ReviewsImagesWhereInput>
    NOT?: Enumerable<ReviewsImagesWhereInput>
    id?: IntFilter | number
    reviewsID?: IntFilter | number
    imageLink?: StringFilter | string
    Reviews?: XOR<ReviewsWhereInput, ReviewsRelationFilter>
  }

  export type ReviewsImagesOrderByInput = {
    id?: SortOrder
    reviewsID?: SortOrder
    imageLink?: SortOrder
  }

  export type ReviewsImagesWhereUniqueInput = {
    id?: number
  }

  export type User_AccountsWhereInput = {
    AND?: Enumerable<User_AccountsWhereInput>
    OR?: Enumerable<User_AccountsWhereInput>
    NOT?: Enumerable<User_AccountsWhereInput>
    id?: StringFilter | string
    hash?: StringFilter | string
    email?: StringFilter | string
    creation_Date?: DateTimeFilter | Date | string
    user?: XOR<UsersWhereInput, UsersRelationFilter> | null
  }

  export type User_AccountsOrderByInput = {
    id?: SortOrder
    hash?: SortOrder
    email?: SortOrder
    creation_Date?: SortOrder
  }

  export type User_AccountsWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UsersWhereInput = {
    AND?: Enumerable<UsersWhereInput>
    OR?: Enumerable<UsersWhereInput>
    NOT?: Enumerable<UsersWhereInput>
    id?: StringFilter | string
    first_name?: StringFilter | string
    last_name?: StringFilter | string
    new_user?: BoolFilter | boolean
    account_ID?: StringFilter | string
    user_img?: StringNullableFilter | string | null
    account?: XOR<User_AccountsWhereInput, User_AccountsRelationFilter>
    reviews?: ReviewsListRelationFilter
  }

  export type UsersOrderByInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    new_user?: SortOrder
    account_ID?: SortOrder
    user_img?: SortOrder
  }

  export type UsersWhereUniqueInput = {
    id?: string
    account_ID?: string
  }

  export type WineriesCreateInput = {
    winery_name: string
    winery_address: string
    winery_desc: string
    coordinates: string
    Vintages?: VintagesCreateManyWithoutWineriesInput
    image?: WineriesImagesCreateManyWithoutWineriesInput
  }

  export type WineriesUpdateInput = {
    winery_name?: StringFieldUpdateOperationsInput | string
    winery_address?: StringFieldUpdateOperationsInput | string
    winery_desc?: StringFieldUpdateOperationsInput | string
    coordinates?: StringFieldUpdateOperationsInput | string
    Vintages?: VintagesUpdateManyWithoutWineriesInput
    image?: WineriesImagesUpdateManyWithoutWineriesInput
  }

  export type WineriesUpdateManyMutationInput = {
    winery_name?: StringFieldUpdateOperationsInput | string
    winery_address?: StringFieldUpdateOperationsInput | string
    winery_desc?: StringFieldUpdateOperationsInput | string
    coordinates?: StringFieldUpdateOperationsInput | string
  }

  export type WineriesImagesCreateInput = {
    imageLink: string
    Wineries: WineriesCreateOneWithoutImageInput
  }

  export type WineriesImagesUpdateInput = {
    imageLink?: StringFieldUpdateOperationsInput | string
    Wineries?: WineriesUpdateOneRequiredWithoutImageInput
  }

  export type WineriesImagesUpdateManyMutationInput = {
    imageLink?: StringFieldUpdateOperationsInput | string
  }

  export type VintagesCreateInput = {
    vintage_name: string
    vintage_year: string
    description: string
    Wineries: WineriesCreateOneWithoutVintagesInput
    Reviews?: ReviewsCreateManyWithoutVintagesInput
    images?: VintagesImagesCreateManyWithoutVintagesInput
  }

  export type VintagesUpdateInput = {
    vintage_name?: StringFieldUpdateOperationsInput | string
    vintage_year?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    Wineries?: WineriesUpdateOneRequiredWithoutVintagesInput
    Reviews?: ReviewsUpdateManyWithoutVintagesInput
    images?: VintagesImagesUpdateManyWithoutVintagesInput
  }

  export type VintagesUpdateManyMutationInput = {
    vintage_name?: StringFieldUpdateOperationsInput | string
    vintage_year?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type VintagesImagesCreateInput = {
    imageLink: string
    Vintages: VintagesCreateOneWithoutImagesInput
  }

  export type VintagesImagesUpdateInput = {
    imageLink?: StringFieldUpdateOperationsInput | string
    Vintages?: VintagesUpdateOneRequiredWithoutImagesInput
  }

  export type VintagesImagesUpdateManyMutationInput = {
    imageLink?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewsCreateInput = {
    user_level: string
    user_review: string
    star_review: number
    timestamp?: Date | string
    likes?: number
    User: UsersCreateOneWithoutReviewsInput
    Vintages: VintagesCreateOneWithoutReviewsInput
    images?: ReviewsImagesCreateManyWithoutReviewsInput
  }

  export type ReviewsUpdateInput = {
    user_level?: StringFieldUpdateOperationsInput | string
    user_review?: StringFieldUpdateOperationsInput | string
    star_review?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    User?: UsersUpdateOneRequiredWithoutReviewsInput
    Vintages?: VintagesUpdateOneRequiredWithoutReviewsInput
    images?: ReviewsImagesUpdateManyWithoutReviewsInput
  }

  export type ReviewsUpdateManyMutationInput = {
    user_level?: StringFieldUpdateOperationsInput | string
    user_review?: StringFieldUpdateOperationsInput | string
    star_review?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewsImagesCreateInput = {
    imageLink: string
    Reviews: ReviewsCreateOneWithoutImagesInput
  }

  export type ReviewsImagesUpdateInput = {
    imageLink?: StringFieldUpdateOperationsInput | string
    Reviews?: ReviewsUpdateOneRequiredWithoutImagesInput
  }

  export type ReviewsImagesUpdateManyMutationInput = {
    imageLink?: StringFieldUpdateOperationsInput | string
  }

  export type User_AccountsCreateInput = {
    id?: string
    hash: string
    email: string
    creation_Date?: Date | string
    user?: UsersCreateOneWithoutAccountInput
  }

  export type User_AccountsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    creation_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneWithoutAccountInput
  }

  export type User_AccountsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    creation_Date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersCreateInput = {
    id?: string
    first_name: string
    last_name: string
    new_user?: boolean
    user_img?: string | null
    account: User_AccountsCreateOneWithoutUserInput
    reviews?: ReviewsCreateManyWithoutUserInput
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    new_user?: BoolFieldUpdateOperationsInput | boolean
    user_img?: NullableStringFieldUpdateOperationsInput | string | null
    account?: User_AccountsUpdateOneRequiredWithoutUserInput
    reviews?: ReviewsUpdateManyWithoutUserInput
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    new_user?: BoolFieldUpdateOperationsInput | boolean
    user_img?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type VintagesListRelationFilter = {
    every?: VintagesWhereInput
    some?: VintagesWhereInput
    none?: VintagesWhereInput
  }

  export type WineriesImagesListRelationFilter = {
    every?: WineriesImagesWhereInput
    some?: WineriesImagesWhereInput
    none?: WineriesImagesWhereInput
  }

  export type WineriesRelationFilter = {
    is?: WineriesWhereInput
    isNot?: WineriesWhereInput
  }

  export type ReviewsListRelationFilter = {
    every?: ReviewsWhereInput
    some?: ReviewsWhereInput
    none?: ReviewsWhereInput
  }

  export type VintagesImagesListRelationFilter = {
    every?: VintagesImagesWhereInput
    some?: VintagesImagesWhereInput
    none?: VintagesImagesWhereInput
  }

  export type VintagesRelationFilter = {
    is?: VintagesWhereInput
    isNot?: VintagesWhereInput
  }

  export type UsersRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ReviewsImagesListRelationFilter = {
    every?: ReviewsImagesWhereInput
    some?: ReviewsImagesWhereInput
    none?: ReviewsImagesWhereInput
  }

  export type ReviewsRelationFilter = {
    is?: ReviewsWhereInput
    isNot?: ReviewsWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type User_AccountsRelationFilter = {
    is?: User_AccountsWhereInput
    isNot?: User_AccountsWhereInput
  }

  export type VintagesCreateManyWithoutWineriesInput = {
    create?: Enumerable<VintagesCreateWithoutWineriesInput>
    connect?: Enumerable<VintagesWhereUniqueInput>
    connectOrCreate?: Enumerable<VintagesCreateOrConnectWithoutWineriesInput>
  }

  export type WineriesImagesCreateManyWithoutWineriesInput = {
    create?: Enumerable<WineriesImagesCreateWithoutWineriesInput>
    connect?: Enumerable<WineriesImagesWhereUniqueInput>
    connectOrCreate?: Enumerable<WineriesImagesCreateOrConnectWithoutWineriesInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type VintagesUpdateManyWithoutWineriesInput = {
    create?: Enumerable<VintagesCreateWithoutWineriesInput>
    connect?: Enumerable<VintagesWhereUniqueInput>
    set?: Enumerable<VintagesWhereUniqueInput>
    disconnect?: Enumerable<VintagesWhereUniqueInput>
    delete?: Enumerable<VintagesWhereUniqueInput>
    update?: Enumerable<VintagesUpdateWithWhereUniqueWithoutWineriesInput>
    updateMany?: Enumerable<VintagesUpdateManyWithWhereWithoutWineriesInput>
    deleteMany?: Enumerable<VintagesScalarWhereInput>
    upsert?: Enumerable<VintagesUpsertWithWhereUniqueWithoutWineriesInput>
    connectOrCreate?: Enumerable<VintagesCreateOrConnectWithoutWineriesInput>
  }

  export type WineriesImagesUpdateManyWithoutWineriesInput = {
    create?: Enumerable<WineriesImagesCreateWithoutWineriesInput>
    connect?: Enumerable<WineriesImagesWhereUniqueInput>
    set?: Enumerable<WineriesImagesWhereUniqueInput>
    disconnect?: Enumerable<WineriesImagesWhereUniqueInput>
    delete?: Enumerable<WineriesImagesWhereUniqueInput>
    update?: Enumerable<WineriesImagesUpdateWithWhereUniqueWithoutWineriesInput>
    updateMany?: Enumerable<WineriesImagesUpdateManyWithWhereWithoutWineriesInput>
    deleteMany?: Enumerable<WineriesImagesScalarWhereInput>
    upsert?: Enumerable<WineriesImagesUpsertWithWhereUniqueWithoutWineriesInput>
    connectOrCreate?: Enumerable<WineriesImagesCreateOrConnectWithoutWineriesInput>
  }

  export type WineriesCreateOneWithoutImageInput = {
    create?: WineriesCreateWithoutImageInput
    connect?: WineriesWhereUniqueInput
    connectOrCreate?: WineriesCreateOrConnectWithoutimageInput
  }

  export type WineriesUpdateOneRequiredWithoutImageInput = {
    create?: WineriesCreateWithoutImageInput
    connect?: WineriesWhereUniqueInput
    update?: WineriesUpdateWithoutImageInput
    upsert?: WineriesUpsertWithoutImageInput
    connectOrCreate?: WineriesCreateOrConnectWithoutimageInput
  }

  export type WineriesCreateOneWithoutVintagesInput = {
    create?: WineriesCreateWithoutVintagesInput
    connect?: WineriesWhereUniqueInput
    connectOrCreate?: WineriesCreateOrConnectWithoutVintagesInput
  }

  export type ReviewsCreateManyWithoutVintagesInput = {
    create?: Enumerable<ReviewsCreateWithoutVintagesInput>
    connect?: Enumerable<ReviewsWhereUniqueInput>
    connectOrCreate?: Enumerable<ReviewsCreateOrConnectWithoutVintagesInput>
  }

  export type VintagesImagesCreateManyWithoutVintagesInput = {
    create?: Enumerable<VintagesImagesCreateWithoutVintagesInput>
    connect?: Enumerable<VintagesImagesWhereUniqueInput>
    connectOrCreate?: Enumerable<VintagesImagesCreateOrConnectWithoutVintagesInput>
  }

  export type WineriesUpdateOneRequiredWithoutVintagesInput = {
    create?: WineriesCreateWithoutVintagesInput
    connect?: WineriesWhereUniqueInput
    update?: WineriesUpdateWithoutVintagesInput
    upsert?: WineriesUpsertWithoutVintagesInput
    connectOrCreate?: WineriesCreateOrConnectWithoutVintagesInput
  }

  export type ReviewsUpdateManyWithoutVintagesInput = {
    create?: Enumerable<ReviewsCreateWithoutVintagesInput>
    connect?: Enumerable<ReviewsWhereUniqueInput>
    set?: Enumerable<ReviewsWhereUniqueInput>
    disconnect?: Enumerable<ReviewsWhereUniqueInput>
    delete?: Enumerable<ReviewsWhereUniqueInput>
    update?: Enumerable<ReviewsUpdateWithWhereUniqueWithoutVintagesInput>
    updateMany?: Enumerable<ReviewsUpdateManyWithWhereWithoutVintagesInput>
    deleteMany?: Enumerable<ReviewsScalarWhereInput>
    upsert?: Enumerable<ReviewsUpsertWithWhereUniqueWithoutVintagesInput>
    connectOrCreate?: Enumerable<ReviewsCreateOrConnectWithoutVintagesInput>
  }

  export type VintagesImagesUpdateManyWithoutVintagesInput = {
    create?: Enumerable<VintagesImagesCreateWithoutVintagesInput>
    connect?: Enumerable<VintagesImagesWhereUniqueInput>
    set?: Enumerable<VintagesImagesWhereUniqueInput>
    disconnect?: Enumerable<VintagesImagesWhereUniqueInput>
    delete?: Enumerable<VintagesImagesWhereUniqueInput>
    update?: Enumerable<VintagesImagesUpdateWithWhereUniqueWithoutVintagesInput>
    updateMany?: Enumerable<VintagesImagesUpdateManyWithWhereWithoutVintagesInput>
    deleteMany?: Enumerable<VintagesImagesScalarWhereInput>
    upsert?: Enumerable<VintagesImagesUpsertWithWhereUniqueWithoutVintagesInput>
    connectOrCreate?: Enumerable<VintagesImagesCreateOrConnectWithoutVintagesInput>
  }

  export type VintagesCreateOneWithoutImagesInput = {
    create?: VintagesCreateWithoutImagesInput
    connect?: VintagesWhereUniqueInput
    connectOrCreate?: VintagesCreateOrConnectWithoutimagesInput
  }

  export type VintagesUpdateOneRequiredWithoutImagesInput = {
    create?: VintagesCreateWithoutImagesInput
    connect?: VintagesWhereUniqueInput
    update?: VintagesUpdateWithoutImagesInput
    upsert?: VintagesUpsertWithoutImagesInput
    connectOrCreate?: VintagesCreateOrConnectWithoutimagesInput
  }

  export type UsersCreateOneWithoutReviewsInput = {
    create?: UsersCreateWithoutReviewsInput
    connect?: UsersWhereUniqueInput
    connectOrCreate?: UsersCreateOrConnectWithoutreviewsInput
  }

  export type VintagesCreateOneWithoutReviewsInput = {
    create?: VintagesCreateWithoutReviewsInput
    connect?: VintagesWhereUniqueInput
    connectOrCreate?: VintagesCreateOrConnectWithoutReviewsInput
  }

  export type ReviewsImagesCreateManyWithoutReviewsInput = {
    create?: Enumerable<ReviewsImagesCreateWithoutReviewsInput>
    connect?: Enumerable<ReviewsImagesWhereUniqueInput>
    connectOrCreate?: Enumerable<ReviewsImagesCreateOrConnectWithoutReviewsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UsersUpdateOneRequiredWithoutReviewsInput = {
    create?: UsersCreateWithoutReviewsInput
    connect?: UsersWhereUniqueInput
    update?: UsersUpdateWithoutReviewsInput
    upsert?: UsersUpsertWithoutReviewsInput
    connectOrCreate?: UsersCreateOrConnectWithoutreviewsInput
  }

  export type VintagesUpdateOneRequiredWithoutReviewsInput = {
    create?: VintagesCreateWithoutReviewsInput
    connect?: VintagesWhereUniqueInput
    update?: VintagesUpdateWithoutReviewsInput
    upsert?: VintagesUpsertWithoutReviewsInput
    connectOrCreate?: VintagesCreateOrConnectWithoutReviewsInput
  }

  export type ReviewsImagesUpdateManyWithoutReviewsInput = {
    create?: Enumerable<ReviewsImagesCreateWithoutReviewsInput>
    connect?: Enumerable<ReviewsImagesWhereUniqueInput>
    set?: Enumerable<ReviewsImagesWhereUniqueInput>
    disconnect?: Enumerable<ReviewsImagesWhereUniqueInput>
    delete?: Enumerable<ReviewsImagesWhereUniqueInput>
    update?: Enumerable<ReviewsImagesUpdateWithWhereUniqueWithoutReviewsInput>
    updateMany?: Enumerable<ReviewsImagesUpdateManyWithWhereWithoutReviewsInput>
    deleteMany?: Enumerable<ReviewsImagesScalarWhereInput>
    upsert?: Enumerable<ReviewsImagesUpsertWithWhereUniqueWithoutReviewsInput>
    connectOrCreate?: Enumerable<ReviewsImagesCreateOrConnectWithoutReviewsInput>
  }

  export type ReviewsCreateOneWithoutImagesInput = {
    create?: ReviewsCreateWithoutImagesInput
    connect?: ReviewsWhereUniqueInput
    connectOrCreate?: ReviewsCreateOrConnectWithoutimagesInput
  }

  export type ReviewsUpdateOneRequiredWithoutImagesInput = {
    create?: ReviewsCreateWithoutImagesInput
    connect?: ReviewsWhereUniqueInput
    update?: ReviewsUpdateWithoutImagesInput
    upsert?: ReviewsUpsertWithoutImagesInput
    connectOrCreate?: ReviewsCreateOrConnectWithoutimagesInput
  }

  export type UsersCreateOneWithoutAccountInput = {
    create?: UsersCreateWithoutAccountInput
    connect?: UsersWhereUniqueInput
    connectOrCreate?: UsersCreateOrConnectWithoutaccountInput
  }

  export type UsersUpdateOneWithoutAccountInput = {
    create?: UsersCreateWithoutAccountInput
    connect?: UsersWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: UsersUpdateWithoutAccountInput
    upsert?: UsersUpsertWithoutAccountInput
    connectOrCreate?: UsersCreateOrConnectWithoutaccountInput
  }

  export type User_AccountsCreateOneWithoutUserInput = {
    create?: User_AccountsCreateWithoutUserInput
    connect?: User_AccountsWhereUniqueInput
    connectOrCreate?: User_AccountsCreateOrConnectWithoutuserInput
  }

  export type ReviewsCreateManyWithoutUserInput = {
    create?: Enumerable<ReviewsCreateWithoutUserInput>
    connect?: Enumerable<ReviewsWhereUniqueInput>
    connectOrCreate?: Enumerable<ReviewsCreateOrConnectWithoutUserInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type User_AccountsUpdateOneRequiredWithoutUserInput = {
    create?: User_AccountsCreateWithoutUserInput
    connect?: User_AccountsWhereUniqueInput
    update?: User_AccountsUpdateWithoutUserInput
    upsert?: User_AccountsUpsertWithoutUserInput
    connectOrCreate?: User_AccountsCreateOrConnectWithoutuserInput
  }

  export type ReviewsUpdateManyWithoutUserInput = {
    create?: Enumerable<ReviewsCreateWithoutUserInput>
    connect?: Enumerable<ReviewsWhereUniqueInput>
    set?: Enumerable<ReviewsWhereUniqueInput>
    disconnect?: Enumerable<ReviewsWhereUniqueInput>
    delete?: Enumerable<ReviewsWhereUniqueInput>
    update?: Enumerable<ReviewsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReviewsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReviewsScalarWhereInput>
    upsert?: Enumerable<ReviewsUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<ReviewsCreateOrConnectWithoutUserInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type VintagesCreateWithoutWineriesInput = {
    vintage_name: string
    vintage_year: string
    description: string
    Reviews?: ReviewsCreateManyWithoutVintagesInput
    images?: VintagesImagesCreateManyWithoutVintagesInput
  }

  export type VintagesCreateOrConnectWithoutWineriesInput = {
    where: VintagesWhereUniqueInput
    create: VintagesCreateWithoutWineriesInput
  }

  export type WineriesImagesCreateWithoutWineriesInput = {
    imageLink: string
  }

  export type WineriesImagesCreateOrConnectWithoutWineriesInput = {
    where: WineriesImagesWhereUniqueInput
    create: WineriesImagesCreateWithoutWineriesInput
  }

  export type VintagesUpdateWithWhereUniqueWithoutWineriesInput = {
    where: VintagesWhereUniqueInput
    data: VintagesUpdateWithoutWineriesInput
  }

  export type VintagesUpdateManyWithWhereWithoutWineriesInput = {
    where: VintagesScalarWhereInput
    data: VintagesUpdateManyMutationInput
  }

  export type VintagesScalarWhereInput = {
    AND?: Enumerable<VintagesScalarWhereInput>
    OR?: Enumerable<VintagesScalarWhereInput>
    NOT?: Enumerable<VintagesScalarWhereInput>
    id?: IntFilter | number
    vintage_name?: StringFilter | string
    vintage_year?: StringFilter | string
    assoc_winery?: IntFilter | number
    description?: StringFilter | string
  }

  export type VintagesUpsertWithWhereUniqueWithoutWineriesInput = {
    where: VintagesWhereUniqueInput
    update: VintagesUpdateWithoutWineriesInput
    create: VintagesCreateWithoutWineriesInput
  }

  export type WineriesImagesUpdateWithWhereUniqueWithoutWineriesInput = {
    where: WineriesImagesWhereUniqueInput
    data: WineriesImagesUpdateWithoutWineriesInput
  }

  export type WineriesImagesUpdateManyWithWhereWithoutWineriesInput = {
    where: WineriesImagesScalarWhereInput
    data: WineriesImagesUpdateManyMutationInput
  }

  export type WineriesImagesScalarWhereInput = {
    AND?: Enumerable<WineriesImagesScalarWhereInput>
    OR?: Enumerable<WineriesImagesScalarWhereInput>
    NOT?: Enumerable<WineriesImagesScalarWhereInput>
    id?: IntFilter | number
    wineryID?: IntFilter | number
    imageLink?: StringFilter | string
  }

  export type WineriesImagesUpsertWithWhereUniqueWithoutWineriesInput = {
    where: WineriesImagesWhereUniqueInput
    update: WineriesImagesUpdateWithoutWineriesInput
    create: WineriesImagesCreateWithoutWineriesInput
  }

  export type WineriesCreateWithoutImageInput = {
    winery_name: string
    winery_address: string
    winery_desc: string
    coordinates: string
    Vintages?: VintagesCreateManyWithoutWineriesInput
  }

  export type WineriesCreateOrConnectWithoutimageInput = {
    where: WineriesWhereUniqueInput
    create: WineriesCreateWithoutImageInput
  }

  export type WineriesUpdateWithoutImageInput = {
    winery_name?: StringFieldUpdateOperationsInput | string
    winery_address?: StringFieldUpdateOperationsInput | string
    winery_desc?: StringFieldUpdateOperationsInput | string
    coordinates?: StringFieldUpdateOperationsInput | string
    Vintages?: VintagesUpdateManyWithoutWineriesInput
  }

  export type WineriesUpsertWithoutImageInput = {
    update: WineriesUpdateWithoutImageInput
    create: WineriesCreateWithoutImageInput
  }

  export type WineriesCreateWithoutVintagesInput = {
    winery_name: string
    winery_address: string
    winery_desc: string
    coordinates: string
    image?: WineriesImagesCreateManyWithoutWineriesInput
  }

  export type WineriesCreateOrConnectWithoutVintagesInput = {
    where: WineriesWhereUniqueInput
    create: WineriesCreateWithoutVintagesInput
  }

  export type ReviewsCreateWithoutVintagesInput = {
    user_level: string
    user_review: string
    star_review: number
    timestamp?: Date | string
    likes?: number
    User: UsersCreateOneWithoutReviewsInput
    images?: ReviewsImagesCreateManyWithoutReviewsInput
  }

  export type ReviewsCreateOrConnectWithoutVintagesInput = {
    where: ReviewsWhereUniqueInput
    create: ReviewsCreateWithoutVintagesInput
  }

  export type VintagesImagesCreateWithoutVintagesInput = {
    imageLink: string
  }

  export type VintagesImagesCreateOrConnectWithoutVintagesInput = {
    where: VintagesImagesWhereUniqueInput
    create: VintagesImagesCreateWithoutVintagesInput
  }

  export type WineriesUpdateWithoutVintagesInput = {
    winery_name?: StringFieldUpdateOperationsInput | string
    winery_address?: StringFieldUpdateOperationsInput | string
    winery_desc?: StringFieldUpdateOperationsInput | string
    coordinates?: StringFieldUpdateOperationsInput | string
    image?: WineriesImagesUpdateManyWithoutWineriesInput
  }

  export type WineriesUpsertWithoutVintagesInput = {
    update: WineriesUpdateWithoutVintagesInput
    create: WineriesCreateWithoutVintagesInput
  }

  export type ReviewsUpdateWithWhereUniqueWithoutVintagesInput = {
    where: ReviewsWhereUniqueInput
    data: ReviewsUpdateWithoutVintagesInput
  }

  export type ReviewsUpdateManyWithWhereWithoutVintagesInput = {
    where: ReviewsScalarWhereInput
    data: ReviewsUpdateManyMutationInput
  }

  export type ReviewsScalarWhereInput = {
    AND?: Enumerable<ReviewsScalarWhereInput>
    OR?: Enumerable<ReviewsScalarWhereInput>
    NOT?: Enumerable<ReviewsScalarWhereInput>
    id?: IntFilter | number
    user_id?: StringFilter | string
    user_level?: StringFilter | string
    user_review?: StringFilter | string
    star_review?: IntFilter | number
    timestamp?: DateTimeFilter | Date | string
    likes?: IntFilter | number
    vintageID?: IntFilter | number
  }

  export type ReviewsUpsertWithWhereUniqueWithoutVintagesInput = {
    where: ReviewsWhereUniqueInput
    update: ReviewsUpdateWithoutVintagesInput
    create: ReviewsCreateWithoutVintagesInput
  }

  export type VintagesImagesUpdateWithWhereUniqueWithoutVintagesInput = {
    where: VintagesImagesWhereUniqueInput
    data: VintagesImagesUpdateWithoutVintagesInput
  }

  export type VintagesImagesUpdateManyWithWhereWithoutVintagesInput = {
    where: VintagesImagesScalarWhereInput
    data: VintagesImagesUpdateManyMutationInput
  }

  export type VintagesImagesScalarWhereInput = {
    AND?: Enumerable<VintagesImagesScalarWhereInput>
    OR?: Enumerable<VintagesImagesScalarWhereInput>
    NOT?: Enumerable<VintagesImagesScalarWhereInput>
    id?: IntFilter | number
    vintagesID?: IntFilter | number
    imageLink?: StringFilter | string
  }

  export type VintagesImagesUpsertWithWhereUniqueWithoutVintagesInput = {
    where: VintagesImagesWhereUniqueInput
    update: VintagesImagesUpdateWithoutVintagesInput
    create: VintagesImagesCreateWithoutVintagesInput
  }

  export type VintagesCreateWithoutImagesInput = {
    vintage_name: string
    vintage_year: string
    description: string
    Wineries: WineriesCreateOneWithoutVintagesInput
    Reviews?: ReviewsCreateManyWithoutVintagesInput
  }

  export type VintagesCreateOrConnectWithoutimagesInput = {
    where: VintagesWhereUniqueInput
    create: VintagesCreateWithoutImagesInput
  }

  export type VintagesUpdateWithoutImagesInput = {
    vintage_name?: StringFieldUpdateOperationsInput | string
    vintage_year?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    Wineries?: WineriesUpdateOneRequiredWithoutVintagesInput
    Reviews?: ReviewsUpdateManyWithoutVintagesInput
  }

  export type VintagesUpsertWithoutImagesInput = {
    update: VintagesUpdateWithoutImagesInput
    create: VintagesCreateWithoutImagesInput
  }

  export type UsersCreateWithoutReviewsInput = {
    id?: string
    first_name: string
    last_name: string
    new_user?: boolean
    user_img?: string | null
    account: User_AccountsCreateOneWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutreviewsInput = {
    where: UsersWhereUniqueInput
    create: UsersCreateWithoutReviewsInput
  }

  export type VintagesCreateWithoutReviewsInput = {
    vintage_name: string
    vintage_year: string
    description: string
    Wineries: WineriesCreateOneWithoutVintagesInput
    images?: VintagesImagesCreateManyWithoutVintagesInput
  }

  export type VintagesCreateOrConnectWithoutReviewsInput = {
    where: VintagesWhereUniqueInput
    create: VintagesCreateWithoutReviewsInput
  }

  export type ReviewsImagesCreateWithoutReviewsInput = {
    imageLink: string
  }

  export type ReviewsImagesCreateOrConnectWithoutReviewsInput = {
    where: ReviewsImagesWhereUniqueInput
    create: ReviewsImagesCreateWithoutReviewsInput
  }

  export type UsersUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    new_user?: BoolFieldUpdateOperationsInput | boolean
    user_img?: NullableStringFieldUpdateOperationsInput | string | null
    account?: User_AccountsUpdateOneRequiredWithoutUserInput
  }

  export type UsersUpsertWithoutReviewsInput = {
    update: UsersUpdateWithoutReviewsInput
    create: UsersCreateWithoutReviewsInput
  }

  export type VintagesUpdateWithoutReviewsInput = {
    vintage_name?: StringFieldUpdateOperationsInput | string
    vintage_year?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    Wineries?: WineriesUpdateOneRequiredWithoutVintagesInput
    images?: VintagesImagesUpdateManyWithoutVintagesInput
  }

  export type VintagesUpsertWithoutReviewsInput = {
    update: VintagesUpdateWithoutReviewsInput
    create: VintagesCreateWithoutReviewsInput
  }

  export type ReviewsImagesUpdateWithWhereUniqueWithoutReviewsInput = {
    where: ReviewsImagesWhereUniqueInput
    data: ReviewsImagesUpdateWithoutReviewsInput
  }

  export type ReviewsImagesUpdateManyWithWhereWithoutReviewsInput = {
    where: ReviewsImagesScalarWhereInput
    data: ReviewsImagesUpdateManyMutationInput
  }

  export type ReviewsImagesScalarWhereInput = {
    AND?: Enumerable<ReviewsImagesScalarWhereInput>
    OR?: Enumerable<ReviewsImagesScalarWhereInput>
    NOT?: Enumerable<ReviewsImagesScalarWhereInput>
    id?: IntFilter | number
    reviewsID?: IntFilter | number
    imageLink?: StringFilter | string
  }

  export type ReviewsImagesUpsertWithWhereUniqueWithoutReviewsInput = {
    where: ReviewsImagesWhereUniqueInput
    update: ReviewsImagesUpdateWithoutReviewsInput
    create: ReviewsImagesCreateWithoutReviewsInput
  }

  export type ReviewsCreateWithoutImagesInput = {
    user_level: string
    user_review: string
    star_review: number
    timestamp?: Date | string
    likes?: number
    User: UsersCreateOneWithoutReviewsInput
    Vintages: VintagesCreateOneWithoutReviewsInput
  }

  export type ReviewsCreateOrConnectWithoutimagesInput = {
    where: ReviewsWhereUniqueInput
    create: ReviewsCreateWithoutImagesInput
  }

  export type ReviewsUpdateWithoutImagesInput = {
    user_level?: StringFieldUpdateOperationsInput | string
    user_review?: StringFieldUpdateOperationsInput | string
    star_review?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    User?: UsersUpdateOneRequiredWithoutReviewsInput
    Vintages?: VintagesUpdateOneRequiredWithoutReviewsInput
  }

  export type ReviewsUpsertWithoutImagesInput = {
    update: ReviewsUpdateWithoutImagesInput
    create: ReviewsCreateWithoutImagesInput
  }

  export type UsersCreateWithoutAccountInput = {
    id?: string
    first_name: string
    last_name: string
    new_user?: boolean
    user_img?: string | null
    reviews?: ReviewsCreateManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutaccountInput = {
    where: UsersWhereUniqueInput
    create: UsersCreateWithoutAccountInput
  }

  export type UsersUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    new_user?: BoolFieldUpdateOperationsInput | boolean
    user_img?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: ReviewsUpdateManyWithoutUserInput
  }

  export type UsersUpsertWithoutAccountInput = {
    update: UsersUpdateWithoutAccountInput
    create: UsersCreateWithoutAccountInput
  }

  export type User_AccountsCreateWithoutUserInput = {
    id?: string
    hash: string
    email: string
    creation_Date?: Date | string
  }

  export type User_AccountsCreateOrConnectWithoutuserInput = {
    where: User_AccountsWhereUniqueInput
    create: User_AccountsCreateWithoutUserInput
  }

  export type ReviewsCreateWithoutUserInput = {
    user_level: string
    user_review: string
    star_review: number
    timestamp?: Date | string
    likes?: number
    Vintages: VintagesCreateOneWithoutReviewsInput
    images?: ReviewsImagesCreateManyWithoutReviewsInput
  }

  export type ReviewsCreateOrConnectWithoutUserInput = {
    where: ReviewsWhereUniqueInput
    create: ReviewsCreateWithoutUserInput
  }

  export type User_AccountsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    creation_Date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_AccountsUpsertWithoutUserInput = {
    update: User_AccountsUpdateWithoutUserInput
    create: User_AccountsCreateWithoutUserInput
  }

  export type ReviewsUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewsWhereUniqueInput
    data: ReviewsUpdateWithoutUserInput
  }

  export type ReviewsUpdateManyWithWhereWithoutUserInput = {
    where: ReviewsScalarWhereInput
    data: ReviewsUpdateManyMutationInput
  }

  export type ReviewsUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewsWhereUniqueInput
    update: ReviewsUpdateWithoutUserInput
    create: ReviewsCreateWithoutUserInput
  }

  export type VintagesUpdateWithoutWineriesInput = {
    vintage_name?: StringFieldUpdateOperationsInput | string
    vintage_year?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    Reviews?: ReviewsUpdateManyWithoutVintagesInput
    images?: VintagesImagesUpdateManyWithoutVintagesInput
  }

  export type WineriesImagesUpdateWithoutWineriesInput = {
    imageLink?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewsUpdateWithoutVintagesInput = {
    user_level?: StringFieldUpdateOperationsInput | string
    user_review?: StringFieldUpdateOperationsInput | string
    star_review?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    User?: UsersUpdateOneRequiredWithoutReviewsInput
    images?: ReviewsImagesUpdateManyWithoutReviewsInput
  }

  export type VintagesImagesUpdateWithoutVintagesInput = {
    imageLink?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewsImagesUpdateWithoutReviewsInput = {
    imageLink?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewsUpdateWithoutUserInput = {
    user_level?: StringFieldUpdateOperationsInput | string
    user_review?: StringFieldUpdateOperationsInput | string
    star_review?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    Vintages?: VintagesUpdateOneRequiredWithoutReviewsInput
    images?: ReviewsImagesUpdateManyWithoutReviewsInput
  }



  /**
   * Batch Payload for updateMany & deleteMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}

/*
* Exports for compatibility introduced in 2.12.0
* Please import from the Prisma namespace instead
*/

/**
 * @deprecated Renamed to `Prisma.WineriesScalarFieldEnum`
 */
export type WineriesScalarFieldEnum = Prisma.WineriesScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.WineriesImagesScalarFieldEnum`
 */
export type WineriesImagesScalarFieldEnum = Prisma.WineriesImagesScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.VintagesScalarFieldEnum`
 */
export type VintagesScalarFieldEnum = Prisma.VintagesScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.VintagesImagesScalarFieldEnum`
 */
export type VintagesImagesScalarFieldEnum = Prisma.VintagesImagesScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.ReviewsScalarFieldEnum`
 */
export type ReviewsScalarFieldEnum = Prisma.ReviewsScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesScalarFieldEnum`
 */
export type ReviewsImagesScalarFieldEnum = Prisma.ReviewsImagesScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.User_AccountsScalarFieldEnum`
 */
export type User_AccountsScalarFieldEnum = Prisma.User_AccountsScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.UsersScalarFieldEnum`
 */
export type UsersScalarFieldEnum = Prisma.UsersScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.SortOrder`
 */
export type SortOrder = Prisma.SortOrder

/**
 * @deprecated Renamed to `Prisma.ModelName`
 */
export type ModelName = Prisma.ModelName

/**
 * @deprecated Renamed to `Prisma.AggregateWineries`
 */
export type AggregateWineries = Prisma.AggregateWineries

/**
 * @deprecated Renamed to `Prisma.WineriesAvgAggregateOutputType`
 */
export type WineriesAvgAggregateOutputType = Prisma.WineriesAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.WineriesSumAggregateOutputType`
 */
export type WineriesSumAggregateOutputType = Prisma.WineriesSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.WineriesMinAggregateOutputType`
 */
export type WineriesMinAggregateOutputType = Prisma.WineriesMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.WineriesMaxAggregateOutputType`
 */
export type WineriesMaxAggregateOutputType = Prisma.WineriesMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.WineriesCountAggregateOutputType`
 */
export type WineriesCountAggregateOutputType = Prisma.WineriesCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateWineriesArgs`
 */
export type AggregateWineriesArgs = Prisma.AggregateWineriesArgs

/**
 * @deprecated Renamed to `Prisma.WineriesAvgAggregateInputType`
 */
export type WineriesAvgAggregateInputType = Prisma.WineriesAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.WineriesSumAggregateInputType`
 */
export type WineriesSumAggregateInputType = Prisma.WineriesSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.WineriesMinAggregateInputType`
 */
export type WineriesMinAggregateInputType = Prisma.WineriesMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.WineriesMaxAggregateInputType`
 */
export type WineriesMaxAggregateInputType = Prisma.WineriesMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.WineriesCountAggregateInputType`
 */
export type WineriesCountAggregateInputType = Prisma.WineriesCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.WineriesSelect`
 */
export type WineriesSelect = Prisma.WineriesSelect

/**
 * @deprecated Renamed to `Prisma.WineriesInclude`
 */
export type WineriesInclude = Prisma.WineriesInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueWineriesArgs`
 */
export type FindUniqueWineriesArgs = Prisma.FindUniqueWineriesArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstWineriesArgs`
 */
export type FindFirstWineriesArgs = Prisma.FindFirstWineriesArgs

/**
 * @deprecated Renamed to `Prisma.FindManyWineriesArgs`
 */
export type FindManyWineriesArgs = Prisma.FindManyWineriesArgs

/**
 * @deprecated Renamed to `Prisma.WineriesCreateArgs`
 */
export type WineriesCreateArgs = Prisma.WineriesCreateArgs

/**
 * @deprecated Renamed to `Prisma.WineriesUpdateArgs`
 */
export type WineriesUpdateArgs = Prisma.WineriesUpdateArgs

/**
 * @deprecated Renamed to `Prisma.WineriesUpdateManyArgs`
 */
export type WineriesUpdateManyArgs = Prisma.WineriesUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.WineriesUpsertArgs`
 */
export type WineriesUpsertArgs = Prisma.WineriesUpsertArgs

/**
 * @deprecated Renamed to `Prisma.WineriesDeleteArgs`
 */
export type WineriesDeleteArgs = Prisma.WineriesDeleteArgs

/**
 * @deprecated Renamed to `Prisma.WineriesDeleteManyArgs`
 */
export type WineriesDeleteManyArgs = Prisma.WineriesDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateWineriesImages`
 */
export type AggregateWineriesImages = Prisma.AggregateWineriesImages

/**
 * @deprecated Renamed to `Prisma.WineriesImagesAvgAggregateOutputType`
 */
export type WineriesImagesAvgAggregateOutputType = Prisma.WineriesImagesAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.WineriesImagesSumAggregateOutputType`
 */
export type WineriesImagesSumAggregateOutputType = Prisma.WineriesImagesSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.WineriesImagesMinAggregateOutputType`
 */
export type WineriesImagesMinAggregateOutputType = Prisma.WineriesImagesMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.WineriesImagesMaxAggregateOutputType`
 */
export type WineriesImagesMaxAggregateOutputType = Prisma.WineriesImagesMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.WineriesImagesCountAggregateOutputType`
 */
export type WineriesImagesCountAggregateOutputType = Prisma.WineriesImagesCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateWineriesImagesArgs`
 */
export type AggregateWineriesImagesArgs = Prisma.AggregateWineriesImagesArgs

/**
 * @deprecated Renamed to `Prisma.WineriesImagesAvgAggregateInputType`
 */
export type WineriesImagesAvgAggregateInputType = Prisma.WineriesImagesAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.WineriesImagesSumAggregateInputType`
 */
export type WineriesImagesSumAggregateInputType = Prisma.WineriesImagesSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.WineriesImagesMinAggregateInputType`
 */
export type WineriesImagesMinAggregateInputType = Prisma.WineriesImagesMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.WineriesImagesMaxAggregateInputType`
 */
export type WineriesImagesMaxAggregateInputType = Prisma.WineriesImagesMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.WineriesImagesCountAggregateInputType`
 */
export type WineriesImagesCountAggregateInputType = Prisma.WineriesImagesCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.WineriesImagesSelect`
 */
export type WineriesImagesSelect = Prisma.WineriesImagesSelect

/**
 * @deprecated Renamed to `Prisma.WineriesImagesInclude`
 */
export type WineriesImagesInclude = Prisma.WineriesImagesInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueWineriesImagesArgs`
 */
export type FindUniqueWineriesImagesArgs = Prisma.FindUniqueWineriesImagesArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstWineriesImagesArgs`
 */
export type FindFirstWineriesImagesArgs = Prisma.FindFirstWineriesImagesArgs

/**
 * @deprecated Renamed to `Prisma.FindManyWineriesImagesArgs`
 */
export type FindManyWineriesImagesArgs = Prisma.FindManyWineriesImagesArgs

/**
 * @deprecated Renamed to `Prisma.WineriesImagesCreateArgs`
 */
export type WineriesImagesCreateArgs = Prisma.WineriesImagesCreateArgs

/**
 * @deprecated Renamed to `Prisma.WineriesImagesUpdateArgs`
 */
export type WineriesImagesUpdateArgs = Prisma.WineriesImagesUpdateArgs

/**
 * @deprecated Renamed to `Prisma.WineriesImagesUpdateManyArgs`
 */
export type WineriesImagesUpdateManyArgs = Prisma.WineriesImagesUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.WineriesImagesUpsertArgs`
 */
export type WineriesImagesUpsertArgs = Prisma.WineriesImagesUpsertArgs

/**
 * @deprecated Renamed to `Prisma.WineriesImagesDeleteArgs`
 */
export type WineriesImagesDeleteArgs = Prisma.WineriesImagesDeleteArgs

/**
 * @deprecated Renamed to `Prisma.WineriesImagesDeleteManyArgs`
 */
export type WineriesImagesDeleteManyArgs = Prisma.WineriesImagesDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateVintages`
 */
export type AggregateVintages = Prisma.AggregateVintages

/**
 * @deprecated Renamed to `Prisma.VintagesAvgAggregateOutputType`
 */
export type VintagesAvgAggregateOutputType = Prisma.VintagesAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.VintagesSumAggregateOutputType`
 */
export type VintagesSumAggregateOutputType = Prisma.VintagesSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.VintagesMinAggregateOutputType`
 */
export type VintagesMinAggregateOutputType = Prisma.VintagesMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.VintagesMaxAggregateOutputType`
 */
export type VintagesMaxAggregateOutputType = Prisma.VintagesMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.VintagesCountAggregateOutputType`
 */
export type VintagesCountAggregateOutputType = Prisma.VintagesCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateVintagesArgs`
 */
export type AggregateVintagesArgs = Prisma.AggregateVintagesArgs

/**
 * @deprecated Renamed to `Prisma.VintagesAvgAggregateInputType`
 */
export type VintagesAvgAggregateInputType = Prisma.VintagesAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VintagesSumAggregateInputType`
 */
export type VintagesSumAggregateInputType = Prisma.VintagesSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VintagesMinAggregateInputType`
 */
export type VintagesMinAggregateInputType = Prisma.VintagesMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VintagesMaxAggregateInputType`
 */
export type VintagesMaxAggregateInputType = Prisma.VintagesMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VintagesCountAggregateInputType`
 */
export type VintagesCountAggregateInputType = Prisma.VintagesCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VintagesSelect`
 */
export type VintagesSelect = Prisma.VintagesSelect

/**
 * @deprecated Renamed to `Prisma.VintagesInclude`
 */
export type VintagesInclude = Prisma.VintagesInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueVintagesArgs`
 */
export type FindUniqueVintagesArgs = Prisma.FindUniqueVintagesArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstVintagesArgs`
 */
export type FindFirstVintagesArgs = Prisma.FindFirstVintagesArgs

/**
 * @deprecated Renamed to `Prisma.FindManyVintagesArgs`
 */
export type FindManyVintagesArgs = Prisma.FindManyVintagesArgs

/**
 * @deprecated Renamed to `Prisma.VintagesCreateArgs`
 */
export type VintagesCreateArgs = Prisma.VintagesCreateArgs

/**
 * @deprecated Renamed to `Prisma.VintagesUpdateArgs`
 */
export type VintagesUpdateArgs = Prisma.VintagesUpdateArgs

/**
 * @deprecated Renamed to `Prisma.VintagesUpdateManyArgs`
 */
export type VintagesUpdateManyArgs = Prisma.VintagesUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.VintagesUpsertArgs`
 */
export type VintagesUpsertArgs = Prisma.VintagesUpsertArgs

/**
 * @deprecated Renamed to `Prisma.VintagesDeleteArgs`
 */
export type VintagesDeleteArgs = Prisma.VintagesDeleteArgs

/**
 * @deprecated Renamed to `Prisma.VintagesDeleteManyArgs`
 */
export type VintagesDeleteManyArgs = Prisma.VintagesDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateVintagesImages`
 */
export type AggregateVintagesImages = Prisma.AggregateVintagesImages

/**
 * @deprecated Renamed to `Prisma.VintagesImagesAvgAggregateOutputType`
 */
export type VintagesImagesAvgAggregateOutputType = Prisma.VintagesImagesAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.VintagesImagesSumAggregateOutputType`
 */
export type VintagesImagesSumAggregateOutputType = Prisma.VintagesImagesSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.VintagesImagesMinAggregateOutputType`
 */
export type VintagesImagesMinAggregateOutputType = Prisma.VintagesImagesMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.VintagesImagesMaxAggregateOutputType`
 */
export type VintagesImagesMaxAggregateOutputType = Prisma.VintagesImagesMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.VintagesImagesCountAggregateOutputType`
 */
export type VintagesImagesCountAggregateOutputType = Prisma.VintagesImagesCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateVintagesImagesArgs`
 */
export type AggregateVintagesImagesArgs = Prisma.AggregateVintagesImagesArgs

/**
 * @deprecated Renamed to `Prisma.VintagesImagesAvgAggregateInputType`
 */
export type VintagesImagesAvgAggregateInputType = Prisma.VintagesImagesAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VintagesImagesSumAggregateInputType`
 */
export type VintagesImagesSumAggregateInputType = Prisma.VintagesImagesSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VintagesImagesMinAggregateInputType`
 */
export type VintagesImagesMinAggregateInputType = Prisma.VintagesImagesMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VintagesImagesMaxAggregateInputType`
 */
export type VintagesImagesMaxAggregateInputType = Prisma.VintagesImagesMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VintagesImagesCountAggregateInputType`
 */
export type VintagesImagesCountAggregateInputType = Prisma.VintagesImagesCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.VintagesImagesSelect`
 */
export type VintagesImagesSelect = Prisma.VintagesImagesSelect

/**
 * @deprecated Renamed to `Prisma.VintagesImagesInclude`
 */
export type VintagesImagesInclude = Prisma.VintagesImagesInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueVintagesImagesArgs`
 */
export type FindUniqueVintagesImagesArgs = Prisma.FindUniqueVintagesImagesArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstVintagesImagesArgs`
 */
export type FindFirstVintagesImagesArgs = Prisma.FindFirstVintagesImagesArgs

/**
 * @deprecated Renamed to `Prisma.FindManyVintagesImagesArgs`
 */
export type FindManyVintagesImagesArgs = Prisma.FindManyVintagesImagesArgs

/**
 * @deprecated Renamed to `Prisma.VintagesImagesCreateArgs`
 */
export type VintagesImagesCreateArgs = Prisma.VintagesImagesCreateArgs

/**
 * @deprecated Renamed to `Prisma.VintagesImagesUpdateArgs`
 */
export type VintagesImagesUpdateArgs = Prisma.VintagesImagesUpdateArgs

/**
 * @deprecated Renamed to `Prisma.VintagesImagesUpdateManyArgs`
 */
export type VintagesImagesUpdateManyArgs = Prisma.VintagesImagesUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.VintagesImagesUpsertArgs`
 */
export type VintagesImagesUpsertArgs = Prisma.VintagesImagesUpsertArgs

/**
 * @deprecated Renamed to `Prisma.VintagesImagesDeleteArgs`
 */
export type VintagesImagesDeleteArgs = Prisma.VintagesImagesDeleteArgs

/**
 * @deprecated Renamed to `Prisma.VintagesImagesDeleteManyArgs`
 */
export type VintagesImagesDeleteManyArgs = Prisma.VintagesImagesDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateReviews`
 */
export type AggregateReviews = Prisma.AggregateReviews

/**
 * @deprecated Renamed to `Prisma.ReviewsAvgAggregateOutputType`
 */
export type ReviewsAvgAggregateOutputType = Prisma.ReviewsAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ReviewsSumAggregateOutputType`
 */
export type ReviewsSumAggregateOutputType = Prisma.ReviewsSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ReviewsMinAggregateOutputType`
 */
export type ReviewsMinAggregateOutputType = Prisma.ReviewsMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ReviewsMaxAggregateOutputType`
 */
export type ReviewsMaxAggregateOutputType = Prisma.ReviewsMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ReviewsCountAggregateOutputType`
 */
export type ReviewsCountAggregateOutputType = Prisma.ReviewsCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateReviewsArgs`
 */
export type AggregateReviewsArgs = Prisma.AggregateReviewsArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsAvgAggregateInputType`
 */
export type ReviewsAvgAggregateInputType = Prisma.ReviewsAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReviewsSumAggregateInputType`
 */
export type ReviewsSumAggregateInputType = Prisma.ReviewsSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReviewsMinAggregateInputType`
 */
export type ReviewsMinAggregateInputType = Prisma.ReviewsMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReviewsMaxAggregateInputType`
 */
export type ReviewsMaxAggregateInputType = Prisma.ReviewsMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReviewsCountAggregateInputType`
 */
export type ReviewsCountAggregateInputType = Prisma.ReviewsCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReviewsSelect`
 */
export type ReviewsSelect = Prisma.ReviewsSelect

/**
 * @deprecated Renamed to `Prisma.ReviewsInclude`
 */
export type ReviewsInclude = Prisma.ReviewsInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueReviewsArgs`
 */
export type FindUniqueReviewsArgs = Prisma.FindUniqueReviewsArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstReviewsArgs`
 */
export type FindFirstReviewsArgs = Prisma.FindFirstReviewsArgs

/**
 * @deprecated Renamed to `Prisma.FindManyReviewsArgs`
 */
export type FindManyReviewsArgs = Prisma.FindManyReviewsArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsCreateArgs`
 */
export type ReviewsCreateArgs = Prisma.ReviewsCreateArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateArgs`
 */
export type ReviewsUpdateArgs = Prisma.ReviewsUpdateArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateManyArgs`
 */
export type ReviewsUpdateManyArgs = Prisma.ReviewsUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsUpsertArgs`
 */
export type ReviewsUpsertArgs = Prisma.ReviewsUpsertArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsDeleteArgs`
 */
export type ReviewsDeleteArgs = Prisma.ReviewsDeleteArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsDeleteManyArgs`
 */
export type ReviewsDeleteManyArgs = Prisma.ReviewsDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateReviewsImages`
 */
export type AggregateReviewsImages = Prisma.AggregateReviewsImages

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesAvgAggregateOutputType`
 */
export type ReviewsImagesAvgAggregateOutputType = Prisma.ReviewsImagesAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesSumAggregateOutputType`
 */
export type ReviewsImagesSumAggregateOutputType = Prisma.ReviewsImagesSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesMinAggregateOutputType`
 */
export type ReviewsImagesMinAggregateOutputType = Prisma.ReviewsImagesMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesMaxAggregateOutputType`
 */
export type ReviewsImagesMaxAggregateOutputType = Prisma.ReviewsImagesMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesCountAggregateOutputType`
 */
export type ReviewsImagesCountAggregateOutputType = Prisma.ReviewsImagesCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateReviewsImagesArgs`
 */
export type AggregateReviewsImagesArgs = Prisma.AggregateReviewsImagesArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesAvgAggregateInputType`
 */
export type ReviewsImagesAvgAggregateInputType = Prisma.ReviewsImagesAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesSumAggregateInputType`
 */
export type ReviewsImagesSumAggregateInputType = Prisma.ReviewsImagesSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesMinAggregateInputType`
 */
export type ReviewsImagesMinAggregateInputType = Prisma.ReviewsImagesMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesMaxAggregateInputType`
 */
export type ReviewsImagesMaxAggregateInputType = Prisma.ReviewsImagesMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesCountAggregateInputType`
 */
export type ReviewsImagesCountAggregateInputType = Prisma.ReviewsImagesCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesSelect`
 */
export type ReviewsImagesSelect = Prisma.ReviewsImagesSelect

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesInclude`
 */
export type ReviewsImagesInclude = Prisma.ReviewsImagesInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueReviewsImagesArgs`
 */
export type FindUniqueReviewsImagesArgs = Prisma.FindUniqueReviewsImagesArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstReviewsImagesArgs`
 */
export type FindFirstReviewsImagesArgs = Prisma.FindFirstReviewsImagesArgs

/**
 * @deprecated Renamed to `Prisma.FindManyReviewsImagesArgs`
 */
export type FindManyReviewsImagesArgs = Prisma.FindManyReviewsImagesArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesCreateArgs`
 */
export type ReviewsImagesCreateArgs = Prisma.ReviewsImagesCreateArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesUpdateArgs`
 */
export type ReviewsImagesUpdateArgs = Prisma.ReviewsImagesUpdateArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesUpdateManyArgs`
 */
export type ReviewsImagesUpdateManyArgs = Prisma.ReviewsImagesUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesUpsertArgs`
 */
export type ReviewsImagesUpsertArgs = Prisma.ReviewsImagesUpsertArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesDeleteArgs`
 */
export type ReviewsImagesDeleteArgs = Prisma.ReviewsImagesDeleteArgs

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesDeleteManyArgs`
 */
export type ReviewsImagesDeleteManyArgs = Prisma.ReviewsImagesDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateUser_Accounts`
 */
export type AggregateUser_Accounts = Prisma.AggregateUser_Accounts

/**
 * @deprecated Renamed to `Prisma.User_AccountsMinAggregateOutputType`
 */
export type User_AccountsMinAggregateOutputType = Prisma.User_AccountsMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_AccountsMaxAggregateOutputType`
 */
export type User_AccountsMaxAggregateOutputType = Prisma.User_AccountsMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_AccountsCountAggregateOutputType`
 */
export type User_AccountsCountAggregateOutputType = Prisma.User_AccountsCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateUser_AccountsArgs`
 */
export type AggregateUser_AccountsArgs = Prisma.AggregateUser_AccountsArgs

/**
 * @deprecated Renamed to `Prisma.User_AccountsMinAggregateInputType`
 */
export type User_AccountsMinAggregateInputType = Prisma.User_AccountsMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_AccountsMaxAggregateInputType`
 */
export type User_AccountsMaxAggregateInputType = Prisma.User_AccountsMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_AccountsCountAggregateInputType`
 */
export type User_AccountsCountAggregateInputType = Prisma.User_AccountsCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_AccountsSelect`
 */
export type User_AccountsSelect = Prisma.User_AccountsSelect

/**
 * @deprecated Renamed to `Prisma.User_AccountsInclude`
 */
export type User_AccountsInclude = Prisma.User_AccountsInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueUser_AccountsArgs`
 */
export type FindUniqueUser_AccountsArgs = Prisma.FindUniqueUser_AccountsArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstUser_AccountsArgs`
 */
export type FindFirstUser_AccountsArgs = Prisma.FindFirstUser_AccountsArgs

/**
 * @deprecated Renamed to `Prisma.FindManyUser_AccountsArgs`
 */
export type FindManyUser_AccountsArgs = Prisma.FindManyUser_AccountsArgs

/**
 * @deprecated Renamed to `Prisma.User_AccountsCreateArgs`
 */
export type User_AccountsCreateArgs = Prisma.User_AccountsCreateArgs

/**
 * @deprecated Renamed to `Prisma.User_AccountsUpdateArgs`
 */
export type User_AccountsUpdateArgs = Prisma.User_AccountsUpdateArgs

/**
 * @deprecated Renamed to `Prisma.User_AccountsUpdateManyArgs`
 */
export type User_AccountsUpdateManyArgs = Prisma.User_AccountsUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.User_AccountsUpsertArgs`
 */
export type User_AccountsUpsertArgs = Prisma.User_AccountsUpsertArgs

/**
 * @deprecated Renamed to `Prisma.User_AccountsDeleteArgs`
 */
export type User_AccountsDeleteArgs = Prisma.User_AccountsDeleteArgs

/**
 * @deprecated Renamed to `Prisma.User_AccountsDeleteManyArgs`
 */
export type User_AccountsDeleteManyArgs = Prisma.User_AccountsDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateUsers`
 */
export type AggregateUsers = Prisma.AggregateUsers

/**
 * @deprecated Renamed to `Prisma.UsersMinAggregateOutputType`
 */
export type UsersMinAggregateOutputType = Prisma.UsersMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.UsersMaxAggregateOutputType`
 */
export type UsersMaxAggregateOutputType = Prisma.UsersMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.UsersCountAggregateOutputType`
 */
export type UsersCountAggregateOutputType = Prisma.UsersCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateUsersArgs`
 */
export type AggregateUsersArgs = Prisma.AggregateUsersArgs

/**
 * @deprecated Renamed to `Prisma.UsersMinAggregateInputType`
 */
export type UsersMinAggregateInputType = Prisma.UsersMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.UsersMaxAggregateInputType`
 */
export type UsersMaxAggregateInputType = Prisma.UsersMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.UsersCountAggregateInputType`
 */
export type UsersCountAggregateInputType = Prisma.UsersCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.UsersSelect`
 */
export type UsersSelect = Prisma.UsersSelect

/**
 * @deprecated Renamed to `Prisma.UsersInclude`
 */
export type UsersInclude = Prisma.UsersInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueUsersArgs`
 */
export type FindUniqueUsersArgs = Prisma.FindUniqueUsersArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstUsersArgs`
 */
export type FindFirstUsersArgs = Prisma.FindFirstUsersArgs

/**
 * @deprecated Renamed to `Prisma.FindManyUsersArgs`
 */
export type FindManyUsersArgs = Prisma.FindManyUsersArgs

/**
 * @deprecated Renamed to `Prisma.UsersCreateArgs`
 */
export type UsersCreateArgs = Prisma.UsersCreateArgs

/**
 * @deprecated Renamed to `Prisma.UsersUpdateArgs`
 */
export type UsersUpdateArgs = Prisma.UsersUpdateArgs

/**
 * @deprecated Renamed to `Prisma.UsersUpdateManyArgs`
 */
export type UsersUpdateManyArgs = Prisma.UsersUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.UsersUpsertArgs`
 */
export type UsersUpsertArgs = Prisma.UsersUpsertArgs

/**
 * @deprecated Renamed to `Prisma.UsersDeleteArgs`
 */
export type UsersDeleteArgs = Prisma.UsersDeleteArgs

/**
 * @deprecated Renamed to `Prisma.UsersDeleteManyArgs`
 */
export type UsersDeleteManyArgs = Prisma.UsersDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.WineriesWhereInput`
 */
export type WineriesWhereInput = Prisma.WineriesWhereInput

/**
 * @deprecated Renamed to `Prisma.WineriesOrderByInput`
 */
export type WineriesOrderByInput = Prisma.WineriesOrderByInput

/**
 * @deprecated Renamed to `Prisma.WineriesWhereUniqueInput`
 */
export type WineriesWhereUniqueInput = Prisma.WineriesWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesWhereInput`
 */
export type WineriesImagesWhereInput = Prisma.WineriesImagesWhereInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesOrderByInput`
 */
export type WineriesImagesOrderByInput = Prisma.WineriesImagesOrderByInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesWhereUniqueInput`
 */
export type WineriesImagesWhereUniqueInput = Prisma.WineriesImagesWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.VintagesWhereInput`
 */
export type VintagesWhereInput = Prisma.VintagesWhereInput

/**
 * @deprecated Renamed to `Prisma.VintagesOrderByInput`
 */
export type VintagesOrderByInput = Prisma.VintagesOrderByInput

/**
 * @deprecated Renamed to `Prisma.VintagesWhereUniqueInput`
 */
export type VintagesWhereUniqueInput = Prisma.VintagesWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesWhereInput`
 */
export type VintagesImagesWhereInput = Prisma.VintagesImagesWhereInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesOrderByInput`
 */
export type VintagesImagesOrderByInput = Prisma.VintagesImagesOrderByInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesWhereUniqueInput`
 */
export type VintagesImagesWhereUniqueInput = Prisma.VintagesImagesWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.ReviewsWhereInput`
 */
export type ReviewsWhereInput = Prisma.ReviewsWhereInput

/**
 * @deprecated Renamed to `Prisma.ReviewsOrderByInput`
 */
export type ReviewsOrderByInput = Prisma.ReviewsOrderByInput

/**
 * @deprecated Renamed to `Prisma.ReviewsWhereUniqueInput`
 */
export type ReviewsWhereUniqueInput = Prisma.ReviewsWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesWhereInput`
 */
export type ReviewsImagesWhereInput = Prisma.ReviewsImagesWhereInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesOrderByInput`
 */
export type ReviewsImagesOrderByInput = Prisma.ReviewsImagesOrderByInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesWhereUniqueInput`
 */
export type ReviewsImagesWhereUniqueInput = Prisma.ReviewsImagesWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.User_AccountsWhereInput`
 */
export type User_AccountsWhereInput = Prisma.User_AccountsWhereInput

/**
 * @deprecated Renamed to `Prisma.User_AccountsOrderByInput`
 */
export type User_AccountsOrderByInput = Prisma.User_AccountsOrderByInput

/**
 * @deprecated Renamed to `Prisma.User_AccountsWhereUniqueInput`
 */
export type User_AccountsWhereUniqueInput = Prisma.User_AccountsWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.UsersWhereInput`
 */
export type UsersWhereInput = Prisma.UsersWhereInput

/**
 * @deprecated Renamed to `Prisma.UsersOrderByInput`
 */
export type UsersOrderByInput = Prisma.UsersOrderByInput

/**
 * @deprecated Renamed to `Prisma.UsersWhereUniqueInput`
 */
export type UsersWhereUniqueInput = Prisma.UsersWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.WineriesCreateInput`
 */
export type WineriesCreateInput = Prisma.WineriesCreateInput

/**
 * @deprecated Renamed to `Prisma.WineriesUpdateInput`
 */
export type WineriesUpdateInput = Prisma.WineriesUpdateInput

/**
 * @deprecated Renamed to `Prisma.WineriesUpdateManyMutationInput`
 */
export type WineriesUpdateManyMutationInput = Prisma.WineriesUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesCreateInput`
 */
export type WineriesImagesCreateInput = Prisma.WineriesImagesCreateInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesUpdateInput`
 */
export type WineriesImagesUpdateInput = Prisma.WineriesImagesUpdateInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesUpdateManyMutationInput`
 */
export type WineriesImagesUpdateManyMutationInput = Prisma.WineriesImagesUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.VintagesCreateInput`
 */
export type VintagesCreateInput = Prisma.VintagesCreateInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpdateInput`
 */
export type VintagesUpdateInput = Prisma.VintagesUpdateInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpdateManyMutationInput`
 */
export type VintagesUpdateManyMutationInput = Prisma.VintagesUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesCreateInput`
 */
export type VintagesImagesCreateInput = Prisma.VintagesImagesCreateInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesUpdateInput`
 */
export type VintagesImagesUpdateInput = Prisma.VintagesImagesUpdateInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesUpdateManyMutationInput`
 */
export type VintagesImagesUpdateManyMutationInput = Prisma.VintagesImagesUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.ReviewsCreateInput`
 */
export type ReviewsCreateInput = Prisma.ReviewsCreateInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateInput`
 */
export type ReviewsUpdateInput = Prisma.ReviewsUpdateInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateManyMutationInput`
 */
export type ReviewsUpdateManyMutationInput = Prisma.ReviewsUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesCreateInput`
 */
export type ReviewsImagesCreateInput = Prisma.ReviewsImagesCreateInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesUpdateInput`
 */
export type ReviewsImagesUpdateInput = Prisma.ReviewsImagesUpdateInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesUpdateManyMutationInput`
 */
export type ReviewsImagesUpdateManyMutationInput = Prisma.ReviewsImagesUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.User_AccountsCreateInput`
 */
export type User_AccountsCreateInput = Prisma.User_AccountsCreateInput

/**
 * @deprecated Renamed to `Prisma.User_AccountsUpdateInput`
 */
export type User_AccountsUpdateInput = Prisma.User_AccountsUpdateInput

/**
 * @deprecated Renamed to `Prisma.User_AccountsUpdateManyMutationInput`
 */
export type User_AccountsUpdateManyMutationInput = Prisma.User_AccountsUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.UsersCreateInput`
 */
export type UsersCreateInput = Prisma.UsersCreateInput

/**
 * @deprecated Renamed to `Prisma.UsersUpdateInput`
 */
export type UsersUpdateInput = Prisma.UsersUpdateInput

/**
 * @deprecated Renamed to `Prisma.UsersUpdateManyMutationInput`
 */
export type UsersUpdateManyMutationInput = Prisma.UsersUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.IntFilter`
 */
export type IntFilter = Prisma.IntFilter

/**
 * @deprecated Renamed to `Prisma.StringFilter`
 */
export type StringFilter = Prisma.StringFilter

/**
 * @deprecated Renamed to `Prisma.VintagesListRelationFilter`
 */
export type VintagesListRelationFilter = Prisma.VintagesListRelationFilter

/**
 * @deprecated Renamed to `Prisma.WineriesImagesListRelationFilter`
 */
export type WineriesImagesListRelationFilter = Prisma.WineriesImagesListRelationFilter

/**
 * @deprecated Renamed to `Prisma.WineriesRelationFilter`
 */
export type WineriesRelationFilter = Prisma.WineriesRelationFilter

/**
 * @deprecated Renamed to `Prisma.ReviewsListRelationFilter`
 */
export type ReviewsListRelationFilter = Prisma.ReviewsListRelationFilter

/**
 * @deprecated Renamed to `Prisma.VintagesImagesListRelationFilter`
 */
export type VintagesImagesListRelationFilter = Prisma.VintagesImagesListRelationFilter

/**
 * @deprecated Renamed to `Prisma.VintagesRelationFilter`
 */
export type VintagesRelationFilter = Prisma.VintagesRelationFilter

/**
 * @deprecated Renamed to `Prisma.UsersRelationFilter`
 */
export type UsersRelationFilter = Prisma.UsersRelationFilter

/**
 * @deprecated Renamed to `Prisma.DateTimeFilter`
 */
export type DateTimeFilter = Prisma.DateTimeFilter

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesListRelationFilter`
 */
export type ReviewsImagesListRelationFilter = Prisma.ReviewsImagesListRelationFilter

/**
 * @deprecated Renamed to `Prisma.ReviewsRelationFilter`
 */
export type ReviewsRelationFilter = Prisma.ReviewsRelationFilter

/**
 * @deprecated Renamed to `Prisma.BoolFilter`
 */
export type BoolFilter = Prisma.BoolFilter

/**
 * @deprecated Renamed to `Prisma.StringNullableFilter`
 */
export type StringNullableFilter = Prisma.StringNullableFilter

/**
 * @deprecated Renamed to `Prisma.User_AccountsRelationFilter`
 */
export type User_AccountsRelationFilter = Prisma.User_AccountsRelationFilter

/**
 * @deprecated Renamed to `Prisma.VintagesCreateManyWithoutWineriesInput`
 */
export type VintagesCreateManyWithoutWineriesInput = Prisma.VintagesCreateManyWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesCreateManyWithoutWineriesInput`
 */
export type WineriesImagesCreateManyWithoutWineriesInput = Prisma.WineriesImagesCreateManyWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.StringFieldUpdateOperationsInput`
 */
export type StringFieldUpdateOperationsInput = Prisma.StringFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpdateManyWithoutWineriesInput`
 */
export type VintagesUpdateManyWithoutWineriesInput = Prisma.VintagesUpdateManyWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesUpdateManyWithoutWineriesInput`
 */
export type WineriesImagesUpdateManyWithoutWineriesInput = Prisma.WineriesImagesUpdateManyWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.WineriesCreateOneWithoutImageInput`
 */
export type WineriesCreateOneWithoutImageInput = Prisma.WineriesCreateOneWithoutImageInput

/**
 * @deprecated Renamed to `Prisma.WineriesUpdateOneRequiredWithoutImageInput`
 */
export type WineriesUpdateOneRequiredWithoutImageInput = Prisma.WineriesUpdateOneRequiredWithoutImageInput

/**
 * @deprecated Renamed to `Prisma.WineriesCreateOneWithoutVintagesInput`
 */
export type WineriesCreateOneWithoutVintagesInput = Prisma.WineriesCreateOneWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsCreateManyWithoutVintagesInput`
 */
export type ReviewsCreateManyWithoutVintagesInput = Prisma.ReviewsCreateManyWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesCreateManyWithoutVintagesInput`
 */
export type VintagesImagesCreateManyWithoutVintagesInput = Prisma.VintagesImagesCreateManyWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.WineriesUpdateOneRequiredWithoutVintagesInput`
 */
export type WineriesUpdateOneRequiredWithoutVintagesInput = Prisma.WineriesUpdateOneRequiredWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateManyWithoutVintagesInput`
 */
export type ReviewsUpdateManyWithoutVintagesInput = Prisma.ReviewsUpdateManyWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesUpdateManyWithoutVintagesInput`
 */
export type VintagesImagesUpdateManyWithoutVintagesInput = Prisma.VintagesImagesUpdateManyWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesCreateOneWithoutImagesInput`
 */
export type VintagesCreateOneWithoutImagesInput = Prisma.VintagesCreateOneWithoutImagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpdateOneRequiredWithoutImagesInput`
 */
export type VintagesUpdateOneRequiredWithoutImagesInput = Prisma.VintagesUpdateOneRequiredWithoutImagesInput

/**
 * @deprecated Renamed to `Prisma.UsersCreateOneWithoutReviewsInput`
 */
export type UsersCreateOneWithoutReviewsInput = Prisma.UsersCreateOneWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.VintagesCreateOneWithoutReviewsInput`
 */
export type VintagesCreateOneWithoutReviewsInput = Prisma.VintagesCreateOneWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesCreateManyWithoutReviewsInput`
 */
export type ReviewsImagesCreateManyWithoutReviewsInput = Prisma.ReviewsImagesCreateManyWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.IntFieldUpdateOperationsInput`
 */
export type IntFieldUpdateOperationsInput = Prisma.IntFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.DateTimeFieldUpdateOperationsInput`
 */
export type DateTimeFieldUpdateOperationsInput = Prisma.DateTimeFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.UsersUpdateOneRequiredWithoutReviewsInput`
 */
export type UsersUpdateOneRequiredWithoutReviewsInput = Prisma.UsersUpdateOneRequiredWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpdateOneRequiredWithoutReviewsInput`
 */
export type VintagesUpdateOneRequiredWithoutReviewsInput = Prisma.VintagesUpdateOneRequiredWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesUpdateManyWithoutReviewsInput`
 */
export type ReviewsImagesUpdateManyWithoutReviewsInput = Prisma.ReviewsImagesUpdateManyWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.ReviewsCreateOneWithoutImagesInput`
 */
export type ReviewsCreateOneWithoutImagesInput = Prisma.ReviewsCreateOneWithoutImagesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateOneRequiredWithoutImagesInput`
 */
export type ReviewsUpdateOneRequiredWithoutImagesInput = Prisma.ReviewsUpdateOneRequiredWithoutImagesInput

/**
 * @deprecated Renamed to `Prisma.UsersCreateOneWithoutAccountInput`
 */
export type UsersCreateOneWithoutAccountInput = Prisma.UsersCreateOneWithoutAccountInput

/**
 * @deprecated Renamed to `Prisma.UsersUpdateOneWithoutAccountInput`
 */
export type UsersUpdateOneWithoutAccountInput = Prisma.UsersUpdateOneWithoutAccountInput

/**
 * @deprecated Renamed to `Prisma.User_AccountsCreateOneWithoutUserInput`
 */
export type User_AccountsCreateOneWithoutUserInput = Prisma.User_AccountsCreateOneWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.ReviewsCreateManyWithoutUserInput`
 */
export type ReviewsCreateManyWithoutUserInput = Prisma.ReviewsCreateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.BoolFieldUpdateOperationsInput`
 */
export type BoolFieldUpdateOperationsInput = Prisma.BoolFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.NullableStringFieldUpdateOperationsInput`
 */
export type NullableStringFieldUpdateOperationsInput = Prisma.NullableStringFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.User_AccountsUpdateOneRequiredWithoutUserInput`
 */
export type User_AccountsUpdateOneRequiredWithoutUserInput = Prisma.User_AccountsUpdateOneRequiredWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateManyWithoutUserInput`
 */
export type ReviewsUpdateManyWithoutUserInput = Prisma.ReviewsUpdateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.NestedIntFilter`
 */
export type NestedIntFilter = Prisma.NestedIntFilter

/**
 * @deprecated Renamed to `Prisma.NestedStringFilter`
 */
export type NestedStringFilter = Prisma.NestedStringFilter

/**
 * @deprecated Renamed to `Prisma.NestedDateTimeFilter`
 */
export type NestedDateTimeFilter = Prisma.NestedDateTimeFilter

/**
 * @deprecated Renamed to `Prisma.NestedBoolFilter`
 */
export type NestedBoolFilter = Prisma.NestedBoolFilter

/**
 * @deprecated Renamed to `Prisma.NestedStringNullableFilter`
 */
export type NestedStringNullableFilter = Prisma.NestedStringNullableFilter

/**
 * @deprecated Renamed to `Prisma.VintagesCreateWithoutWineriesInput`
 */
export type VintagesCreateWithoutWineriesInput = Prisma.VintagesCreateWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.VintagesCreateOrConnectWithoutWineriesInput`
 */
export type VintagesCreateOrConnectWithoutWineriesInput = Prisma.VintagesCreateOrConnectWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesCreateWithoutWineriesInput`
 */
export type WineriesImagesCreateWithoutWineriesInput = Prisma.WineriesImagesCreateWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesCreateOrConnectWithoutWineriesInput`
 */
export type WineriesImagesCreateOrConnectWithoutWineriesInput = Prisma.WineriesImagesCreateOrConnectWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpdateWithWhereUniqueWithoutWineriesInput`
 */
export type VintagesUpdateWithWhereUniqueWithoutWineriesInput = Prisma.VintagesUpdateWithWhereUniqueWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpdateManyWithWhereWithoutWineriesInput`
 */
export type VintagesUpdateManyWithWhereWithoutWineriesInput = Prisma.VintagesUpdateManyWithWhereWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.VintagesScalarWhereInput`
 */
export type VintagesScalarWhereInput = Prisma.VintagesScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpsertWithWhereUniqueWithoutWineriesInput`
 */
export type VintagesUpsertWithWhereUniqueWithoutWineriesInput = Prisma.VintagesUpsertWithWhereUniqueWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesUpdateWithWhereUniqueWithoutWineriesInput`
 */
export type WineriesImagesUpdateWithWhereUniqueWithoutWineriesInput = Prisma.WineriesImagesUpdateWithWhereUniqueWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesUpdateManyWithWhereWithoutWineriesInput`
 */
export type WineriesImagesUpdateManyWithWhereWithoutWineriesInput = Prisma.WineriesImagesUpdateManyWithWhereWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesScalarWhereInput`
 */
export type WineriesImagesScalarWhereInput = Prisma.WineriesImagesScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesUpsertWithWhereUniqueWithoutWineriesInput`
 */
export type WineriesImagesUpsertWithWhereUniqueWithoutWineriesInput = Prisma.WineriesImagesUpsertWithWhereUniqueWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.WineriesCreateWithoutImageInput`
 */
export type WineriesCreateWithoutImageInput = Prisma.WineriesCreateWithoutImageInput

/**
 * @deprecated Renamed to `Prisma.WineriesCreateOrConnectWithoutimageInput`
 */
export type WineriesCreateOrConnectWithoutimageInput = Prisma.WineriesCreateOrConnectWithoutimageInput

/**
 * @deprecated Renamed to `Prisma.WineriesUpdateWithoutImageInput`
 */
export type WineriesUpdateWithoutImageInput = Prisma.WineriesUpdateWithoutImageInput

/**
 * @deprecated Renamed to `Prisma.WineriesUpsertWithoutImageInput`
 */
export type WineriesUpsertWithoutImageInput = Prisma.WineriesUpsertWithoutImageInput

/**
 * @deprecated Renamed to `Prisma.WineriesCreateWithoutVintagesInput`
 */
export type WineriesCreateWithoutVintagesInput = Prisma.WineriesCreateWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.WineriesCreateOrConnectWithoutVintagesInput`
 */
export type WineriesCreateOrConnectWithoutVintagesInput = Prisma.WineriesCreateOrConnectWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsCreateWithoutVintagesInput`
 */
export type ReviewsCreateWithoutVintagesInput = Prisma.ReviewsCreateWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsCreateOrConnectWithoutVintagesInput`
 */
export type ReviewsCreateOrConnectWithoutVintagesInput = Prisma.ReviewsCreateOrConnectWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesCreateWithoutVintagesInput`
 */
export type VintagesImagesCreateWithoutVintagesInput = Prisma.VintagesImagesCreateWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesCreateOrConnectWithoutVintagesInput`
 */
export type VintagesImagesCreateOrConnectWithoutVintagesInput = Prisma.VintagesImagesCreateOrConnectWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.WineriesUpdateWithoutVintagesInput`
 */
export type WineriesUpdateWithoutVintagesInput = Prisma.WineriesUpdateWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.WineriesUpsertWithoutVintagesInput`
 */
export type WineriesUpsertWithoutVintagesInput = Prisma.WineriesUpsertWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateWithWhereUniqueWithoutVintagesInput`
 */
export type ReviewsUpdateWithWhereUniqueWithoutVintagesInput = Prisma.ReviewsUpdateWithWhereUniqueWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateManyWithWhereWithoutVintagesInput`
 */
export type ReviewsUpdateManyWithWhereWithoutVintagesInput = Prisma.ReviewsUpdateManyWithWhereWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsScalarWhereInput`
 */
export type ReviewsScalarWhereInput = Prisma.ReviewsScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpsertWithWhereUniqueWithoutVintagesInput`
 */
export type ReviewsUpsertWithWhereUniqueWithoutVintagesInput = Prisma.ReviewsUpsertWithWhereUniqueWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesUpdateWithWhereUniqueWithoutVintagesInput`
 */
export type VintagesImagesUpdateWithWhereUniqueWithoutVintagesInput = Prisma.VintagesImagesUpdateWithWhereUniqueWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesUpdateManyWithWhereWithoutVintagesInput`
 */
export type VintagesImagesUpdateManyWithWhereWithoutVintagesInput = Prisma.VintagesImagesUpdateManyWithWhereWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesScalarWhereInput`
 */
export type VintagesImagesScalarWhereInput = Prisma.VintagesImagesScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesUpsertWithWhereUniqueWithoutVintagesInput`
 */
export type VintagesImagesUpsertWithWhereUniqueWithoutVintagesInput = Prisma.VintagesImagesUpsertWithWhereUniqueWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesCreateWithoutImagesInput`
 */
export type VintagesCreateWithoutImagesInput = Prisma.VintagesCreateWithoutImagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesCreateOrConnectWithoutimagesInput`
 */
export type VintagesCreateOrConnectWithoutimagesInput = Prisma.VintagesCreateOrConnectWithoutimagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpdateWithoutImagesInput`
 */
export type VintagesUpdateWithoutImagesInput = Prisma.VintagesUpdateWithoutImagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpsertWithoutImagesInput`
 */
export type VintagesUpsertWithoutImagesInput = Prisma.VintagesUpsertWithoutImagesInput

/**
 * @deprecated Renamed to `Prisma.UsersCreateWithoutReviewsInput`
 */
export type UsersCreateWithoutReviewsInput = Prisma.UsersCreateWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.UsersCreateOrConnectWithoutreviewsInput`
 */
export type UsersCreateOrConnectWithoutreviewsInput = Prisma.UsersCreateOrConnectWithoutreviewsInput

/**
 * @deprecated Renamed to `Prisma.VintagesCreateWithoutReviewsInput`
 */
export type VintagesCreateWithoutReviewsInput = Prisma.VintagesCreateWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.VintagesCreateOrConnectWithoutReviewsInput`
 */
export type VintagesCreateOrConnectWithoutReviewsInput = Prisma.VintagesCreateOrConnectWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesCreateWithoutReviewsInput`
 */
export type ReviewsImagesCreateWithoutReviewsInput = Prisma.ReviewsImagesCreateWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesCreateOrConnectWithoutReviewsInput`
 */
export type ReviewsImagesCreateOrConnectWithoutReviewsInput = Prisma.ReviewsImagesCreateOrConnectWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.UsersUpdateWithoutReviewsInput`
 */
export type UsersUpdateWithoutReviewsInput = Prisma.UsersUpdateWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.UsersUpsertWithoutReviewsInput`
 */
export type UsersUpsertWithoutReviewsInput = Prisma.UsersUpsertWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpdateWithoutReviewsInput`
 */
export type VintagesUpdateWithoutReviewsInput = Prisma.VintagesUpdateWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpsertWithoutReviewsInput`
 */
export type VintagesUpsertWithoutReviewsInput = Prisma.VintagesUpsertWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesUpdateWithWhereUniqueWithoutReviewsInput`
 */
export type ReviewsImagesUpdateWithWhereUniqueWithoutReviewsInput = Prisma.ReviewsImagesUpdateWithWhereUniqueWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesUpdateManyWithWhereWithoutReviewsInput`
 */
export type ReviewsImagesUpdateManyWithWhereWithoutReviewsInput = Prisma.ReviewsImagesUpdateManyWithWhereWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesScalarWhereInput`
 */
export type ReviewsImagesScalarWhereInput = Prisma.ReviewsImagesScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesUpsertWithWhereUniqueWithoutReviewsInput`
 */
export type ReviewsImagesUpsertWithWhereUniqueWithoutReviewsInput = Prisma.ReviewsImagesUpsertWithWhereUniqueWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.ReviewsCreateWithoutImagesInput`
 */
export type ReviewsCreateWithoutImagesInput = Prisma.ReviewsCreateWithoutImagesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsCreateOrConnectWithoutimagesInput`
 */
export type ReviewsCreateOrConnectWithoutimagesInput = Prisma.ReviewsCreateOrConnectWithoutimagesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateWithoutImagesInput`
 */
export type ReviewsUpdateWithoutImagesInput = Prisma.ReviewsUpdateWithoutImagesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpsertWithoutImagesInput`
 */
export type ReviewsUpsertWithoutImagesInput = Prisma.ReviewsUpsertWithoutImagesInput

/**
 * @deprecated Renamed to `Prisma.UsersCreateWithoutAccountInput`
 */
export type UsersCreateWithoutAccountInput = Prisma.UsersCreateWithoutAccountInput

/**
 * @deprecated Renamed to `Prisma.UsersCreateOrConnectWithoutaccountInput`
 */
export type UsersCreateOrConnectWithoutaccountInput = Prisma.UsersCreateOrConnectWithoutaccountInput

/**
 * @deprecated Renamed to `Prisma.UsersUpdateWithoutAccountInput`
 */
export type UsersUpdateWithoutAccountInput = Prisma.UsersUpdateWithoutAccountInput

/**
 * @deprecated Renamed to `Prisma.UsersUpsertWithoutAccountInput`
 */
export type UsersUpsertWithoutAccountInput = Prisma.UsersUpsertWithoutAccountInput

/**
 * @deprecated Renamed to `Prisma.User_AccountsCreateWithoutUserInput`
 */
export type User_AccountsCreateWithoutUserInput = Prisma.User_AccountsCreateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.User_AccountsCreateOrConnectWithoutuserInput`
 */
export type User_AccountsCreateOrConnectWithoutuserInput = Prisma.User_AccountsCreateOrConnectWithoutuserInput

/**
 * @deprecated Renamed to `Prisma.ReviewsCreateWithoutUserInput`
 */
export type ReviewsCreateWithoutUserInput = Prisma.ReviewsCreateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.ReviewsCreateOrConnectWithoutUserInput`
 */
export type ReviewsCreateOrConnectWithoutUserInput = Prisma.ReviewsCreateOrConnectWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.User_AccountsUpdateWithoutUserInput`
 */
export type User_AccountsUpdateWithoutUserInput = Prisma.User_AccountsUpdateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.User_AccountsUpsertWithoutUserInput`
 */
export type User_AccountsUpsertWithoutUserInput = Prisma.User_AccountsUpsertWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateWithWhereUniqueWithoutUserInput`
 */
export type ReviewsUpdateWithWhereUniqueWithoutUserInput = Prisma.ReviewsUpdateWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateManyWithWhereWithoutUserInput`
 */
export type ReviewsUpdateManyWithWhereWithoutUserInput = Prisma.ReviewsUpdateManyWithWhereWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpsertWithWhereUniqueWithoutUserInput`
 */
export type ReviewsUpsertWithWhereUniqueWithoutUserInput = Prisma.ReviewsUpsertWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.VintagesUpdateWithoutWineriesInput`
 */
export type VintagesUpdateWithoutWineriesInput = Prisma.VintagesUpdateWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.WineriesImagesUpdateWithoutWineriesInput`
 */
export type WineriesImagesUpdateWithoutWineriesInput = Prisma.WineriesImagesUpdateWithoutWineriesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateWithoutVintagesInput`
 */
export type ReviewsUpdateWithoutVintagesInput = Prisma.ReviewsUpdateWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.VintagesImagesUpdateWithoutVintagesInput`
 */
export type VintagesImagesUpdateWithoutVintagesInput = Prisma.VintagesImagesUpdateWithoutVintagesInput

/**
 * @deprecated Renamed to `Prisma.ReviewsImagesUpdateWithoutReviewsInput`
 */
export type ReviewsImagesUpdateWithoutReviewsInput = Prisma.ReviewsImagesUpdateWithoutReviewsInput

/**
 * @deprecated Renamed to `Prisma.ReviewsUpdateWithoutUserInput`
 */
export type ReviewsUpdateWithoutUserInput = Prisma.ReviewsUpdateWithoutUserInput